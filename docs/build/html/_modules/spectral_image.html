

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spectral_image &mdash; EELSfitter 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> EELSfitter
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/datasets.html">Datasets</a></li>
</ul>
<p class="caption"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theory/kk_analysis.html">Kramer-Kronig Analysis</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../implementation/training_strategies.html">Training Strategies</a></li>
</ul>
<p class="caption"><span class="caption-text">Results</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../results/EELS_10.html">EELS 1.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../results/EELS_20.html">EELS 2.0</a></li>
</ul>
<p class="caption"><span class="caption-text">Code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/modules.html">Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EELSfitter</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>spectral_image</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for spectral_image</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">next_fast_len</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">ncempy.io</span> <span class="kn">import</span> <span class="n">dm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">_pickle</span> <span class="k">as</span> <span class="nn">cPickle</span>

<span class="kn">from</span> <span class="nn">k_means_clustering</span> <span class="kn">import</span> <span class="n">k_means</span>
<span class="kn">import</span> <span class="nn">training</span> <span class="k">as</span> <span class="nn">train</span>

<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="SpectralImage"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage">[docs]</a><span class="k">class</span> <span class="nc">SpectralImage</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The spectral image class that provides several tools to analyse spectral images with the zero-loss peak</span>
<span class="sd">    subtracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array_like</span>
<span class="sd">        Array containing the 3-D spectral image. The axes correspond to the x-axis, y-axis and energy-loss.</span>
<span class="sd">    deltadeltaE: float</span>
<span class="sd">        bin width in energy loss spectrum</span>
<span class="sd">    pixelsize: array_like, optional</span>
<span class="sd">        width of pixels</span>
<span class="sd">    beam_energy: float, optional</span>
<span class="sd">        Energy of electron beam in eV</span>
<span class="sd">    collection_angle: float, optional</span>
<span class="sd">        Collection angle of STEM in rad</span>
<span class="sd">    name: str, optional</span>
<span class="sd">        Title of the plots</span>
<span class="sd">    dielectric_function_im_avg</span>
<span class="sd">        average dielectric function for each pixel</span>
<span class="sd">    dielectric_function_im_std</span>
<span class="sd">        standard deviation of the dielectric function at each energy per pixel</span>
<span class="sd">    S_s_avg</span>
<span class="sd">        average surface scattering distribution for each pixel</span>
<span class="sd">    S_s_std</span>
<span class="sd">        standard deviation of the surface scattering distribution at each energy for each pixel</span>
<span class="sd">    thickness_avg</span>
<span class="sd">        average thickness for each pixel</span>
<span class="sd">    IEELS_avg</span>
<span class="sd">        average bulk scattering distribution for each pixel</span>
<span class="sd">    IEELS_std</span>
<span class="sd">        standard deviation of the bulk scattering distribution at each energy for each pixel</span>
<span class="sd">    cluster_data: array_like</span>
<span class="sd">        filled with 2D numpy arrays. If save_as_attribute set to True, the cluster data is also saved as attribute</span>
<span class="sd">    deltaE: array_like</span>
<span class="sd">        shifted array of energy losses such that the zero point corresponds to the point of highest intensity.</span>
<span class="sd">    x_axis: array_like</span>
<span class="sd">        x-axis of the spectral image</span>
<span class="sd">    y_axis: array_like</span>
<span class="sd">        y-axis of the spectral image</span>
<span class="sd">    clusters: array_like</span>
<span class="sd">        cluster means of each cluster</span>
<span class="sd">    clustered: array_like</span>
<span class="sd">        A 2D array containing the index of the cluster to which each pixel belongs</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    An example how to train and anlyse a spectral image::</span>

<span class="sd">        dm4_path = &#39;path to dm4 file&#39;</span>
<span class="sd">        im = SpectralImage.load_data(dm4_path)</span>
<span class="sd">        im.train_zlp(n_clusters=n_clusters,</span>
<span class="sd">                 n_rep=n_rep,</span>
<span class="sd">                 n_epochs=n_epochs,</span>
<span class="sd">                 bs_rep_num=bs_rep_num,</span>
<span class="sd">                 path_to_models=path_to_models,</span>
<span class="sd">                 display_step=display_step)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#  signal names</span>
    <span class="n">DIELECTRIC_FUNCTION_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dielectric_function&#39;</span><span class="p">,</span> <span class="s1">&#39;dielectricfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;dielec_func&#39;</span><span class="p">,</span> <span class="s1">&#39;die_fun&#39;</span><span class="p">,</span> <span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">]</span>
    <span class="n">EELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;electron_energy_loss_spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;electron_energy_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="s1">&#39;EEL&#39;</span><span class="p">,</span> <span class="s1">&#39;energy_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">IEELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inelastic_scattering_energy_loss_spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;inelastic_scattering_energy_loss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;inelastic_scattering&#39;</span><span class="p">,</span> <span class="s1">&#39;IEELS&#39;</span><span class="p">,</span> <span class="s1">&#39;IES&#39;</span><span class="p">]</span>
    <span class="n">ZLP_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;zeros_loss_peak&#39;</span><span class="p">,</span> <span class="s1">&#39;zero_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLP&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLPs&#39;</span><span class="p">,</span> <span class="s1">&#39;zlp&#39;</span><span class="p">,</span> <span class="s1">&#39;zlps&#39;</span><span class="p">]</span>
    <span class="n">THICKNESS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;thick&#39;</span><span class="p">,</span> <span class="s1">&#39;thin&#39;</span><span class="p">]</span>
    <span class="n">POOLED_ADDITION</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;pool&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;_pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;_pool&#39;</span><span class="p">,</span> <span class="s1">&#39;_p&#39;</span><span class="p">]</span>

    <span class="c1"># meta data names</span>
    <span class="n">COLLECTION_ANGLE_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;collection_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;col_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]</span>
    <span class="n">BEAM_ENERGY_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;beam_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;beam_E&quot;</span><span class="p">,</span> <span class="s2">&quot;E_beam&quot;</span><span class="p">,</span> <span class="s2">&quot;E0&quot;</span><span class="p">,</span> <span class="s2">&quot;E_0&quot;</span><span class="p">]</span>

    <span class="n">m_0</span> <span class="o">=</span> <span class="mf">5.1106E5</span>  <span class="c1"># eV, electron rest mass</span>
    <span class="n">a_0</span> <span class="o">=</span> <span class="mf">5.29E-11</span>  <span class="c1"># m, Bohr radius</span>
    <span class="n">h_bar</span> <span class="o">=</span> <span class="mf">6.582119569E-16</span>  <span class="c1"># eV/s</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.99792458E8</span>  <span class="c1"># m/s</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">deltadeltaE</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beam_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">collection_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dielectric_function_im_avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dielectric_function_im_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S_s_avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S_s_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">thickness_avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thickness_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IEELS_avg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IEELS_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clustered</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cluster_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deltaE</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">deltadeltaE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_deltaE</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pixelsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span> <span class="o">*</span> <span class="mf">1E6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_axes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">beam_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">=</span> <span class="n">beam_energy</span>
        <span class="k">if</span> <span class="n">collection_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="o">=</span> <span class="n">collection_angle</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="n">dielectric_function_im_avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="n">dielectric_function_im_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="n">S_s_avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="n">S_s_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">thickness_avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">thickness_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">IEELS_avg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">IEELS_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">clustered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_data</span> <span class="o">=</span> <span class="n">cluster_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="n">x_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="n">y_axis</span>


<div class="viewcode-block" id="SpectralImage.save_image"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.save_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save image, including all attributes, in pickle (.pkl) format. Image will be saved \</span>
<span class="sd">        at indicated location and name in filename input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            path to save location plus filename. If it does not end on &quot;.pkl&quot;, &quot;.pkl&quot; will be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>  <span class="c1"># Overwrites any existing file.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectralImage.save_compressed_image"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.save_compressed_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_compressed_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save image, including all attributes, in compressed pickle (.pbz2) format. Image will \</span>
<span class="sd">            be saved at location ``filename``. Advantage over :py:meth:`save_image() &lt;save_image&gt;` is that \</span>
<span class="sd">            the saved file has a reduced file size, disadvantage is that saving and reloading the image \</span>
<span class="sd">            takes significantly longer.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            path to save location plus filename. If it does not end on &quot;.pbz2&quot;, &quot;.pbz2&quot; will be added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;.pbz2&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectralImage.compressed_pickle"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.compressed_pickle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="c1"># Pickle a file and then compress it into a file with extension </span>
    <span class="k">def</span> <span class="nf">compressed_pickle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves ``data`` at location ``title`` as compressed pickle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectralImage.decompress_pickle"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.decompress_pickle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decompress_pickle</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens, decompresses and returns the pickle file at location ``file``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file: str</span>
<span class="sd">            location where the pickle file is stored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: SpectralImage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

    <span class="c1"># %%GENERAL FUNCTIONS</span>

    <span class="c1"># %%PROPERTIES</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns length of :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object, i.e. num energy loss bins&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns 2D-shape of :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns 3D-shape of :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of clusters in the :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of spectra present in :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nspectra: int</span>
<span class="sd">            number of spectra in spectral image&quot;&quot;&quot;</span>
        <span class="n">nspectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nspectra</span>

<div class="viewcode-block" id="SpectralImage.load_data"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.load_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_dmfile</span><span class="p">,</span> <span class="n">load_additional_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the .dm4 spectral image and return a :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_dmfile: str</span>
<span class="sd">            location of .dm4 file</span>
<span class="sd">        load_additional_data: bool, optional</span>
<span class="sd">            Default is `False`. If `True`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectralImage</span>
<span class="sd">            :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` instance of the dm4 file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmfile_tot</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">fileDM</span><span class="p">(</span><span class="n">path_to_dmfile</span><span class="p">)</span>
        <span class="n">additional_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span> <span class="o">*</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">load_additional_data</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="n">load_additional_data</span><span class="p">:</span>
                <span class="n">additional_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additional_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">load_additional_data</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No spectral image detected&quot;</span><span class="p">)</span>
                    <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

        <span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">energyUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ddeltaE</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">energyUnit</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>
        <span class="n">pixelUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">pixelUnit</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddeltaE</span><span class="p">,</span> <span class="n">pixelsize</span><span class="o">=</span><span class="n">pixelsize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">path_to_dmfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">load_additional_data</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">additional_data</span> <span class="o">=</span> <span class="n">additional_data</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="SpectralImage.load_spectral_image"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.load_spectral_image">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_pickle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` instance from a pickled file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_pickle : str</span>
<span class="sd">            path to the pickled image file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If path_to_pickle does not end on the desired format .pkl.</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If path_to_pickle does not exists.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectralImage</span>
<span class="sd">            :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` object (i.e. including all attributes) loaded from pickle file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path_to_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;please provide a path to a pickle file containing a Spectrall_image class object.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;pickled file: &#39;</span> <span class="o">+</span> <span class="n">path_to_pickle</span> <span class="o">+</span> <span class="s1">&#39; not found&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickle_im</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pickle_im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="SpectralImage.load_compressed_Spectral_image"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.load_compressed_Spectral_image">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_compressed_Spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_compressed_pickle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads spectral image from a compressed pickled file. This will take longer than loading from non compressed pickle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_compressed_pickle : str</span>
<span class="sd">            path to the compressed pickle image file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If path_to_compressed_pickle does not end on the desired format .pbz2.</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If path_to_compressed_pickle does not exists.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : SpectralImage</span>
<span class="sd">             :py:meth:`spectral_image.SpectralImage &lt;spectral_image.SpectralImage&gt;` instance loaded from the compressed pickle file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path_to_compressed_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;please provide a path to a compressed .pbz2 pickle file containing a Spectrall_image class object.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_compressed_pickle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;pickled file: &#39;</span> <span class="o">+</span> <span class="n">path_to_compressed_pickle</span> <span class="o">+</span> <span class="s1">&#39; not found&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">decompress_pickle</span><span class="p">(</span><span class="n">path_to_compressed_pickle</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>

<div class="viewcode-block" id="SpectralImage.set_n"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.set_n">[docs]</a>    <span class="k">def</span> <span class="nf">set_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_background</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets value of refractive index for the image as attribute self.n. If unclusered, n will be an \</span>
<span class="sd">            array of length one, otherwise it is an array of len n_clusters. If n_background is defined, \</span>
<span class="sd">            the cluster with the lowest thickness (cluster 0) will be assumed to be the vacuum/background, \</span>
<span class="sd">            and gets the value of the background refractive index.</span>
<span class="sd">            </span>
<span class="sd">        If there are more specimen present in the image, it is wise to check by hand what cluster belongs \</span>
<span class="sd">            to what specimen, and set the values by running::</span>

<span class="sd">             image.n[cluster_i] = n_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : float</span>
<span class="sd">            refractive index of sample.</span>
<span class="sd">        n_background : float, optional</span>
<span class="sd">            if defined: the refractive index of the background/vacuum. This value will automatically be \</span>
<span class="sd">            assigned to pixels belonging to the thinnest cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
            <span class="k">if</span> <span class="n">n_background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># assume thinnest cluster (=cluster 0) is background</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_background</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span></div>

<div class="viewcode-block" id="SpectralImage.determine_deltaE"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.determine_deltaE">[docs]</a>    <span class="k">def</span> <span class="nf">determine_deltaE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the energy losses of the spectral image, based on the bin width of the energy loss.</span>
<span class="sd">        It shifts the ``self.deltaE`` attribute such that the zero point corresponds with the point of highest</span>
<span class="sd">        intensity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deltaE: array_like</span>
<span class="sd">            Array of :math:`\Delta E` values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data_avg</span><span class="p">)</span>
        <span class="n">deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ind_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">-</span> <span class="n">ind_max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deltaE</span></div>

<div class="viewcode-block" id="SpectralImage.calc_axes"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.calc_axes">[docs]</a>    <span class="k">def</span> <span class="nf">calc_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the  x_axis and y_axis of the spectral image. Stores them in ``self.x_axis`` and ``self.y_axis`` respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SpectralImage.get_pixel_signal"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.get_pixel_signal">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixel_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the spectrum at pixel (``i``, ``j``)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        j: int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        signal: str, optional</span>
<span class="sd">            The type of signal that is requested, should comply with the defined names. Set to `EELS` by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signal : array_like</span>
<span class="sd">            Array with the requested signal from the requested pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="o">==</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pooled</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no such signal&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;, returned general EELS signal.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span></div>

    <span class="k">def</span> <span class="nf">get_image_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        <span class="c1"># TODO: add alternative signals + names</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="o">==</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pooled</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no such signal&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;, returned general EELS data.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="SpectralImage.get_cluster_spectra"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.get_cluster_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s2">&quot;EELS&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a clustered spectral image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conf_interval : float, optional</span>
<span class="sd">            The ratio of spectra returned. The spectra are selected based on the </span>
<span class="sd">            based_on value. The default is 1.</span>
<span class="sd">        clusters : list of ints, optional</span>
<span class="sd">            list with all the cluster labels.</span>
<span class="sd">        signal: str, optional</span>
<span class="sd">            Description of signal, ``&quot;EELS&quot;`` by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_data : array_like</span>
<span class="sd">            An array with size equal to the number of clusters. Each entry is a 2D array that contains all the spectra within that cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: check clustering before everything</span>
        <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>

        <span class="n">integrated_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">data_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="n">signal</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">conf_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">intensities_cluster</span> <span class="o">=</span> <span class="n">integrated_int</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">arg_sort_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">intensities_cluster</span><span class="p">)</span>
                <span class="n">ci_lim</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">conf_interval</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">intensities_cluster</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># TODO: ask juan: round up or down?</span>
                <span class="n">data_cluster</span> <span class="o">=</span> <span class="n">data_cluster</span><span class="p">[</span><span class="n">arg_sort_int</span><span class="p">][</span><span class="n">ci_lim</span><span class="p">:</span><span class="o">-</span><span class="n">ci_lim</span><span class="p">]</span>
            <span class="n">cluster_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_cluster</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cluster_data</span></div>

    <span class="k">def</span> <span class="nf">deltaE_to_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">-</span> <span class="n">E</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">E</span>
        <span class="c1"># TODO: check if works</span>

    <span class="c1"># %%METHODS ON SIGNAL</span>

<div class="viewcode-block" id="SpectralImage.cut"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">E2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">in_ex</span><span class="o">=</span><span class="s2">&quot;in&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cuts the spectral image at ``E1`` and ``E2`` and keeps only the part in between.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E1 : float, optional</span>
<span class="sd">            lower cut. The default is ``None``, which means no cut is applied.</span>
<span class="sd">        E2 : float, optional</span>
<span class="sd">            upper cut. The default is ``None``, which means no cut is applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">E1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">E2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To cut energy spectra, please specify minimum energy E1 and/or maximum energy E2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">E2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">in_ex</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;=</span> <span class="n">E2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">E2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">select</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">select</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">cut_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_width</span><span class="p">,</span> <span class="n">range_height</span><span class="p">):</span>
        <span class="c1"># TODO: add floats for cutting to meter sizes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># TODO</span>
    <span class="k">def</span> <span class="nf">samenvoegen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="SpectralImage.smooth"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">keep_original</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth the data using a window length ``window_len``.</span>
<span class="sd">        </span>
<span class="sd">        This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">        The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">        (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">        in the beginning and end part of the output signal.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window_len: int, optional</span>
<span class="sd">            The dimension of the smoothing window; should be an odd integer.</span>
<span class="sd">        window: str, optional</span>
<span class="sd">            the type of window from ``&quot;flat&quot;``, ``&quot;hanning&quot;``,  ``&quot;bartlett&quot;``, ``&quot;blackman&quot;``.</span>
<span class="sd">            ``&quot;flat&quot;`` will produce a moving average smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: add comnparison</span>
        <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;-1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>  <span class="c1"># moving average</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

        <span class="c1"># y=np.convolve(w/w.sum(),s,mode=&#39;valid&#39;)</span>
        <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_original</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span>
                               <span class="p">:,</span> <span class="p">:,</span> <span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[:,</span> <span class="p">:,</span>
                        <span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">):</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Drude model, can also use estimation from exp. data</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_times_extra</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">sem_inf</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_times_extra</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>

        <span class="n">y_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">y_ZLP_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span>
                              <span class="n">sem_inf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="n">sem_inf</span><span class="p">)</span>

        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span><span class="p">)</span>

        <span class="n">y_ZLP_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZLP</span>
        <span class="n">y_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">x_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span>

        <span class="n">y_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">],</span> <span class="o">-</span><span class="n">r</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x_extrp</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y_extrp</span>
        <span class="n">y_ZLP</span> <span class="o">=</span> <span class="n">y_ZLP_extrp</span>

        <span class="n">z_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_ZLP</span><span class="p">)</span>
        <span class="n">i_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">abs_i_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">i_nu</span><span class="p">)</span>
        <span class="n">N_ZLP</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># scipy.integrate.cumtrapz(y_ZLP, x, initial=0)[-1]#1 #arbitrary units??? np.sum(EELZLP)</span>

        <span class="n">s_nu</span> <span class="o">=</span> <span class="n">N_ZLP</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">i_nu</span> <span class="o">/</span> <span class="n">z_nu</span><span class="p">)</span>
        <span class="n">j1_nu</span> <span class="o">=</span> <span class="n">z_nu</span> <span class="o">*</span> <span class="n">s_nu</span> <span class="o">/</span> <span class="n">N_ZLP</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s_nu</span><span class="p">))</span>
        <span class="n">s_nu_nc</span> <span class="o">=</span> <span class="n">s_nu</span>
        <span class="n">s_nu_nc</span><span class="p">[</span><span class="mi">500</span><span class="p">:</span><span class="o">-</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">S_E_nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s_nu_nc</span><span class="p">))</span>
        <span class="n">J1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j1_nu</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">J1_E</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_p</span><span class="p">):</span>
        <span class="c1"># TODO: add gaussian options ed??</span>
        <span class="k">if</span> <span class="n">n_p</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to pool with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_p=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">n_p</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pooled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n_p_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n_p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">pooled</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">min_x</span><span class="p">:</span><span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">:</span><span class="n">max_y</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pooled</span> <span class="o">=</span> <span class="n">pooled</span>

    <span class="c1"># %%METHODS ON ZLP</span>
    <span class="c1"># CALCULATING ZLPs FROM PRETRAINDED MODELS</span>

    <span class="k">def</span> <span class="nf">calc_ZLPs2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;No ZLP models found. Please specify directory or train models. </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;Do you want to define path to models [p], train models [t] or quit [q]?</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;q&quot;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span>
                <span class="n">path_to_models</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Please input path to models: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You had your chance. Please locate your models.&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_zlp</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_zlp</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;path_to_models&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">path_to_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;path_to_models&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unvalid input, not calculating ZLPs&quot;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="c1"># TODO: aanpassen</span>
        <span class="k">def</span> <span class="nf">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">gen_i_ZLP</span><span class="p">,</span> <span class="n">dE1</span><span class="p">):</span>
            <span class="n">dE0</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="c1"># gen_i_ZLP = self.ZLPs_gen[ind_ZLP, :]#*np.max(signal)/np.max(self.ZLPs_gen[ind_ZLP,:]) #TODO!!!!, normalize?</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">dE1</span> <span class="o">-</span> <span class="n">dE0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>  <span class="c1"># lau: 3</span>

            <span class="c1"># factor_NN = np.exp(- np.divide((self.deltaE[(self.deltaE&lt;dE1) &amp; (self.deltaE &gt;= dE0)] - dE1)**2, delta**2))</span>
            <span class="n">factor_NN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">-</span> <span class="p">(</span><span class="n">dE0</span> <span class="o">+</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span><span class="p">))</span>
            <span class="n">factor_dm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_NN</span>

            <span class="n">range_0</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE0</span><span class="p">]</span>
            <span class="n">range_1</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_NN</span> <span class="o">+</span> <span class="n">signal</span><span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_dm</span>
            <span class="n">range_2</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span>
            <span class="n">range_3</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">range_0</span><span class="p">,</span> <span class="n">range_1</span><span class="p">,</span> <span class="n">range_2</span><span class="p">,</span> <span class="n">range_3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># TODO: now hardcoding no negative values!!!! CHECKKKK</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">totalfile</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">totalfile</span>

        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span>  <span class="c1"># np.zeros((count, len_data))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_deltaE&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_log_sum_I&quot;</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>

        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>

        <span class="n">dE1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster:&quot;</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="s2">&quot;, dE1:&quot;</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)</span>  <span class="c1"># matching(energies, np.exp(mean_k), data)</span>

        <span class="k">if</span> <span class="n">select_ZLPs</span><span class="p">:</span>
            <span class="n">ZLPs</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">select_ZLPs</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">ZLPs</span>

    <span class="k">def</span> <span class="nf">calc_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>

        <span class="c1"># TODO: aanpassen</span>
        <span class="k">def</span> <span class="nf">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">gen_i_ZLP</span><span class="p">,</span> <span class="n">dE1</span><span class="p">):</span>
            <span class="n">dE0</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="c1"># gen_i_ZLP = self.ZLPs_gen[ind_ZLP, :]#*np.max(signal)/np.max(self.ZLPs_gen[ind_ZLP,:]) #TODO!!!!, normalize?</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">dE1</span> <span class="o">-</span> <span class="n">dE0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>  <span class="c1"># lau: 3</span>

            <span class="c1"># factor_NN = np.exp(- np.divide((self.deltaE[(self.deltaE&lt;dE1) &amp; (self.deltaE &gt;= dE0)] - dE1)**2, delta**2))</span>
            <span class="n">factor_NN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">-</span> <span class="p">(</span><span class="n">dE0</span> <span class="o">+</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span><span class="p">))</span>
            <span class="n">factor_dm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_NN</span>

            <span class="n">range_0</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE0</span><span class="p">]</span>
            <span class="n">range_1</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_NN</span> <span class="o">+</span> <span class="n">signal</span><span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_dm</span>
            <span class="n">range_2</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span>
            <span class="n">range_3</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">range_0</span><span class="p">,</span> <span class="n">range_1</span><span class="p">,</span> <span class="n">range_2</span><span class="p">,</span> <span class="n">range_3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># TODO: now hardcoding no negative values!!!! CHECKKKK</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">totalfile</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">totalfile</span>

        <span class="n">ZLPs_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_gen_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ZLPs_gen</span><span class="p">)</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span>  <span class="c1"># np.zeros((count, len_data))</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">dE1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">ZLPs_gen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)</span>  <span class="c1"># matching(energies, np.exp(mean_k), data)</span>
        <span class="k">return</span> <span class="n">ZLPs</span>

    <span class="k">def</span> <span class="nf">calc_gen_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s2">&quot;eels&quot;</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

        <span class="c1"># TODO: use the smefit version</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">()</span>

        <span class="c1"># if not hasattr(self, &#39;ZLP_models&#39;):</span>
        <span class="c1">#     ans = input(&quot;No ZLP models found. Please specify directory or train models. \n&quot; +</span>
        <span class="c1">#                 &quot;Do you want to define path to models [p], train models [t] or quit [q]?\n&quot;)</span>
        <span class="c1">#     if ans[0] == &quot;q&quot;:</span>
        <span class="c1">#         return</span>
        <span class="c1">#     elif ans[0] == &quot;p&quot;:</span>
        <span class="c1">#         path_to_models = input(&quot;Please input path to models: \n&quot;)</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             self.load_ZLP_models_smefit(**kwargs)</span>
        <span class="c1">#         except:</span>
        <span class="c1">#             self.load_ZLP_models_smefit()</span>
        <span class="c1">#         if not hasattr(self, &#39;ZLP_models&#39;):</span>
        <span class="c1">#             print(&quot;You had your chance. Please locate your models.&quot;)</span>
        <span class="c1">#             return</span>
        <span class="c1">#     elif ans[0] == &quot;t&quot;:</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             self.train_zlp(**kwargs)</span>
        <span class="c1">#         except:</span>
        <span class="c1">#             self.train_zlp()</span>
        <span class="c1">#         if &quot;path_to_models&quot; in kwargs:</span>
        <span class="c1">#             path_to_models = kwargs[&quot;path_to_models&quot;]</span>
        <span class="c1">#             self.load_ZLP_models_smefit(path_to_models)</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             self.load_ZLP_models_smefit()</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         print(&quot;unvalid input, not calculating ZLPs&quot;)</span>
        <span class="c1">#         return</span>

        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span>  <span class="c1"># np.zeros((count, len_data))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_deltaE&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_log_sum_I&quot;</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>

        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">select_ZLPs</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">select_ZLPs</span><span class="p">(</span><span class="n">predictions</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">predictions</span>

    <span class="k">def</span> <span class="nf">select_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ZLPs</span><span class="p">,</span> <span class="n">dE1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dE1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dE1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE1</span>

        <span class="n">ZLPs_c</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[:,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE2</span><span class="p">)]</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ZLPs_c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ZLPs_c</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="n">low</span><span class="p">[</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">high</span><span class="p">[</span><span class="n">high</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span>

        <span class="n">check</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZLPs_c</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ZLPs_c</span> <span class="o">&gt;=</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">check_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">check</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">check_sum</span><span class="p">,</span> <span class="mi">85</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">check_sum</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_ZLPs_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ZLPs</span><span class="p">,</span> <span class="n">dE1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dE1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dE1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE1</span>

        <span class="n">ZLPs_c</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[:,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE2</span><span class="p">)]</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ZLPs_c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ZLPs_c</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">100</span>

        <span class="n">low</span><span class="p">[</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">high</span><span class="p">[</span><span class="n">high</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshold</span>

        <span class="n">check</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZLPs_c</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ZLPs_c</span> <span class="o">&gt;=</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">check</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.01</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">check</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>

<div class="viewcode-block" id="SpectralImage.train_zlp"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.train_zlp">[docs]</a>    <span class="k">def</span> <span class="nf">train_zlp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">conf_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the ZLP on the spectral image.</span>

<span class="sd">        The spectral image is clustered in ``n_clusters`` clusters, according to e.g. the integrated intensity or thickness.</span>
<span class="sd">        A random spectrum is then taken from each cluster, which together defines one replica. The training is initiated</span>
<span class="sd">        by calling :py:meth:`train_zlp_scaled() &lt;training.train_zlp_scaled&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters: int, optional</span>
<span class="sd">            number of clusters</span>
<span class="sd">        conf_interval: int, optional</span>
<span class="sd">            Default is 1</span>
<span class="sd">        clusters</span>
<span class="sd">        signal: str, optional</span>
<span class="sd">            Type of spectrum. Set to EELS by default.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments that are passed to the method :py:meth:`train_zlp_scaled() &lt;training.train_zlp_scaled&gt;` in the :py:mod:`training` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>

        <span class="n">training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_spectra</span><span class="p">(</span><span class="n">conf_interval</span><span class="o">=</span><span class="n">conf_interval</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">train</span><span class="o">.</span><span class="n">train_zlp_scaled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">load_ZLP_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="n">threshold_costs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name_in_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plotting</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">path_to_models</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No path &quot;</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot; found. Please ensure spelling and that there are models trained.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/costs.txt&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;chi^2 distribution of models&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;chi^2&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;number of occurence&quot;</span><span class="p">)</span>

        <span class="n">n_working_models</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">costs</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/nn_rep&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                        <span class="c1"># TODO: this check is unnesscicary I believe, to be removed</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;disregarded model, straight line.&quot;</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_cost_smefit</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="s1">&#39;/&#39;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;costs&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">threshold</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
        <span class="n">deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaE</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">predictions</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1E-3</span>  <span class="c1"># very small --&gt; straight line</span>

    <span class="k">def</span> <span class="nf">load_ZLP_models_smefit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="n">threshold_costs</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">name_in_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plotting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># if n_rep is None and idx is None:</span>
        <span class="c1">#     print(&quot;Please spectify either the number of replicas you wish to load (n_rep)&quot;+\</span>
        <span class="c1">#           &quot; or the specific replica model you wist to load (idx) in load_ZLP_models_smefit.&quot;)</span>
        <span class="c1">#     return</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">path_to_models</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;No path &quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot; found. Please ensure spelling and that there are models trained.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="s1">&#39;/&#39;</span>
        <span class="n">path_dE1</span> <span class="o">=</span> <span class="s2">&quot;dE1.txt&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">path_dE1</span><span class="p">)</span>

        <span class="n">path_scale_var</span> <span class="o">=</span> <span class="s1">&#39;scale_var.txt&#39;</span>  <span class="c1"># HIER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">path_scale_var</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">path_scale_var_deltaE</span> <span class="o">=</span> <span class="s1">&#39;scale_var_deltaE.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">path_scale_var_deltaE</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;found delta E vars&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustered&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;image clustered in &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot; clusters, but ZLP-models take &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="s2">&quot; clusters, reclustering based on models.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/nn_rep_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">path_costs</span> <span class="o">=</span> <span class="s2">&quot;costs_test_&quot;</span>
        <span class="n">files_costs</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">path_costs</span><span class="p">)]</span>
        <span class="c1">#idx_costs = np.array([int(s.replace(path_costs, &quot;&quot;).replace(&quot;.txt&quot;, &quot;&quot;)) for s in files_costs])</span>
        <span class="c1"># path_model_rep = &quot;nn_rep_&quot;</span>
        <span class="c1"># files_model_rep = [filename for filename in os.listdir(path_to_models) if filename.startswith(path_model_rep)]</span>
        <span class="c1"># idx_models = np.array([int(s.replace(path_model_rep, &quot;&quot;).replace(&quot;.txt&quot;, &quot;&quot;)) for s in files_model_rep])</span>
        <span class="c1">#</span>
        <span class="c1"># overlap_idx = np.intersect1d(idx_costs, idx_models)</span>

        <span class="c1">#n_rep = len(overlap_idx)</span>
        <span class="c1">#costs = np.zeros(n_rep)</span>
        <span class="c1">#files_models = np.zeros(n_rep, dtype=&#39;U12&#39;)  # reads max 999,999 models, you really do not need more.</span>

        <span class="c1"># for i in range(n_rep):</span>
        <span class="c1">#     file = files_costs[i]</span>
        <span class="c1">#     costs[i] =  np.loadtxt(path_to_models + file)</span>

        <span class="n">bs_rep_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">files_costs</span><span class="p">)</span>

        <span class="n">cost_tests</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cost_trains</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bs_rep_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">path_tests</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;costs_test_</span><span class="si">{}</span><span class="s1">.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">path_trains</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;costs_train_</span><span class="si">{}</span><span class="s1">.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_tests</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">cost_tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_trains</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">cost_trains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>

        <span class="n">cost_tests</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">)</span>
        <span class="n">cost_tests_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">)</span>
        <span class="n">cost_tests_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">,</span> <span class="mi">68</span><span class="p">)</span>
        <span class="n">threshold_costs_tests</span> <span class="o">=</span> <span class="n">cost_tests_mean</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">cost_tests_std</span>
        <span class="n">cost_tests</span> <span class="o">=</span> <span class="n">cost_tests</span><span class="p">[</span><span class="n">cost_tests</span> <span class="o">&lt;</span> <span class="n">threshold_costs_tests</span><span class="p">]</span>

        <span class="n">cost_trains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">)</span>
        <span class="n">cost_trains_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">)</span>
        <span class="n">cost_trains_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">,</span> <span class="mi">68</span><span class="p">)</span>
        <span class="n">threshold_costs_trains</span> <span class="o">=</span> <span class="n">cost_trains_mean</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">cost_trains_std</span>
        <span class="n">nn_rep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cost_trains</span> <span class="o">&lt;</span> <span class="n">threshold_costs_trains</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">cost_trains</span> <span class="o">=</span> <span class="n">cost_trains</span><span class="p">[</span><span class="n">cost_trains</span> <span class="o">&lt;</span> <span class="n">threshold_costs_trains</span><span class="p">]</span>

        <span class="c1"># plot the chi2 distributions</span>
        <span class="c1"># TODO: add option to function call whether to plot or not</span>
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\rm</span><span class="si">{Training}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span> <span class="n">cost_tests_std</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\rm</span><span class="si">{Validation}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span> <span class="n">cost_tests_std</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\chi^2\;\rm</span><span class="si">{distribution}</span><span class="s1">$&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\chi^2$&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;/data/theorie/jthoeve/EELSfitter/output/chi2.pdf&#39;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">nn_rep_idx</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;nn_rep_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>


    <span class="c1"># METHODS ON DIELECTRIC FUNCTIONS</span>
<div class="viewcode-block" id="SpectralImage.calc_thickness"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.calc_thickness">[docs]</a>    <span class="k">def</span> <span class="nf">calc_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spect</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N_ZLP</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates thickness from sample data, using Egerton [1]_</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spect : array_like</span>
<span class="sd">            spectral image</span>
<span class="sd">        n : float</span>
<span class="sd">            refraction index</span>
<span class="sd">        N_ZLP: float or int</span>
<span class="sd">            Set to 1 by default, for already normalized EELS spectra.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        te: float</span>
<span class="sd">            thickness</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Surface scatterings are not corrected for. If you wish to correct</span>
<span class="sd">        for surface scatterings, please extract the thickness ``t`` from :py:meth:`kramers_kronig_hs() &lt;kramers_kronig_hs&gt;`.</span>


<span class="sd">        .. [1] Ray Egerton, &quot;Electron Energy-Loss Spectroscopy in the Electron</span>
<span class="sd">           Microscope&quot;, Springer-Verlag, 2011.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_0</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e0</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

        <span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># axis.axis.copy()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">spect</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">N_ZLP</span>

        <span class="c1"># Kinetic definitions</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span>

        <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
        <span class="c1"># We start by the &quot;angular corrections&quot;</span>
        <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span>  <span class="c1"># axis.scale</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span>
        <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">i0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">te</span></div>

<div class="viewcode-block" id="SpectralImage.kramers_kronig_hs"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.kramers_kronig_hs">[docs]</a>    <span class="k">def</span> <span class="nf">kramers_kronig_hs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_EELS</span><span class="p">,</span>
                          <span class="n">N_ZLP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">correct_S_s</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the complex</span>
<span class="sd">        dielectric function from a single scattering distribution (SSD) using</span>
<span class="sd">        the Kramers-Kronig relations.</span>
<span class="sd">    </span>
<span class="sd">        It uses the FFT method as in [1]_.  The SSD is an</span>
<span class="sd">        EELSSpectrum instance containing SSD low-loss EELS with no zero-loss</span>
<span class="sd">        peak. The internal loop is devised to approximately subtract the</span>
<span class="sd">        surface plasmon contribution supposing an unoxidized planar surface and</span>
<span class="sd">        neglecting coupling between the surfaces. This method does not account</span>
<span class="sd">        for retardation effects, instrumental broading and surface plasmon</span>
<span class="sd">        excitation in particles.</span>
<span class="sd">    </span>
<span class="sd">        Note that either refractive index or thickness are required.</span>
<span class="sd">        If both are None or if both are provided an exception is raised.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zlp: {None, number, Signal1D}</span>
<span class="sd">            ZLP intensity. It is optional (can be None) if `t` is None and `n`</span>
<span class="sd">            is not None and the thickness estimation is not required. If `t`</span>
<span class="sd">            is not None, the ZLP is required to perform the normalization and</span>
<span class="sd">            if `t` is not None, the ZLP is required to calculate the thickness.</span>
<span class="sd">            If the ZLP is the same for all spectra, the integral of the ZLP</span>
<span class="sd">            can be provided as a number. Otherwise, if the ZLP intensity is not</span>
<span class="sd">            the same for all spectra, it can be provided as i) a Signal1D</span>
<span class="sd">            of the same dimensions as the current signal containing the ZLP</span>
<span class="sd">            spectra for each location ii) a BaseSignal of signal dimension 0</span>
<span class="sd">            and navigation_dimension equal to the current signal containing the</span>
<span class="sd">            integrated ZLP intensity.</span>
<span class="sd">        iterations: int</span>
<span class="sd">            Number of the iterations for the internal loop to remove the</span>
<span class="sd">            surface plasmon contribution. If 1 the surface plasmon contribution</span>
<span class="sd">            is not estimated and subtracted (the default is 1).</span>
<span class="sd">        n: {None, float}</span>
<span class="sd">            The medium refractive index. Used for normalization of the</span>
<span class="sd">            SSD to obtain the energy loss function. If given the thickness</span>
<span class="sd">            is estimated and returned. It is only required when `t` is None.</span>
<span class="sd">        t: {None, number, Signal1D}</span>
<span class="sd">            The sample thickness in nm. Used for normalization of the</span>
<span class="sd">            to obtain the energy loss function. It is only required when</span>
<span class="sd">            `n` is None. If the thickness is the same for all spectra it can be</span>
<span class="sd">            `n` is None. If the thickness is the same for all spectra it can be</span>
<span class="sd">            given by a number. Otherwise, it can be provided as a BaseSignal</span>
<span class="sd">            with signal dimension 0 and navigation_dimension equal to the</span>
<span class="sd">            current signal.</span>
<span class="sd">        delta : float</span>
<span class="sd">            A small number (0.1-0.5 eV) added to the energy axis in</span>
<span class="sd">            specific steps of the calculation the surface loss correction to</span>
<span class="sd">            improve stability.</span>
<span class="sd">        full_output : bool</span>
<span class="sd">            If True, return a dictionary that contains the estimated</span>
<span class="sd">            thickness if `t` is None and the estimated surface plasmon</span>
<span class="sd">            excitation and the spectrum corrected from surface plasmon</span>
<span class="sd">            excitations if `iterations` &gt; 1.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eps: DielectricFunction instance</span>
<span class="sd">            The complex dielectric function results,</span>
<span class="sd">    </span>
<span class="sd">                .. math::</span>
<span class="sd">                    \epsilon = \epsilon_1 + i*\epsilon_2,</span>
<span class="sd">    </span>
<span class="sd">            contained in an DielectricFunction instance.</span>
<span class="sd">        output: Dictionary (optional)</span>
<span class="sd">            A dictionary of optional outputs with the following keys:</span>
<span class="sd">    </span>
<span class="sd">            ``thickness``</span>
<span class="sd">                The estimated  thickness in nm calculated by normalization of</span>
<span class="sd">                the SSD (only when `t` is None)</span>
<span class="sd">    </span>
<span class="sd">            ``surface plasmon estimation``</span>
<span class="sd">               The estimated surface plasmon excitation (only if</span>
<span class="sd">               `iterations` &gt; 1.)</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValuerError</span>
<span class="sd">            If both `n` and `t` are undefined (None).</span>
<span class="sd">        AttribureError</span>
<span class="sd">            If the beam_energy or the collection semi-angle are not defined in</span>
<span class="sd">            metadata.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is based in Egerton&#39;s Matlab code [1]_ with some</span>
<span class="sd">        minor differences:</span>
<span class="sd">    </span>
<span class="sd">        * The wrap-around problem when computing the ffts is workarounded by</span>
<span class="sd">          padding the signal instead of substracting the reflected tail.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        .. [1] Ray Egerton, &quot;Electron Energy-Loss Spectroscopy in the Electron</span>
<span class="sd">           Microscope&quot;, Springer-Verlag, 2011.</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Constants and units</span>
        <span class="n">me</span> <span class="o">=</span> <span class="mf">511.06</span>

        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e0</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

        <span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># axis.axis.copy()</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eaxis</span><span class="p">)</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">N_ZLP</span>

        <span class="c1"># Kinetic definitions</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># m0 v**2</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span>
        <span class="n">rk0</span> <span class="o">=</span> <span class="mi">2590</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span>  <span class="c1"># me c**2 / (hbar c) gamma sqrt(2Ekin /(me c**2))</span>

        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
            <span class="c1"># We start by the &quot;angular corrections&quot;</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span>  <span class="c1"># axis.scale</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The thickness and the refractive index are &quot;</span>
                                 <span class="s2">&quot;not defined. Please provide one of them.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide the refractive index OR the &quot;</span>
                                 <span class="s2">&quot;thickness information, not both&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># normalize using the refractive index.</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">i0</span><span class="p">)</span>

            <span class="n">Im</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="n">K</span>

            <span class="c1"># Kramers Kronig Transform:</span>
            <span class="c1"># We calculate KKT(Im(-1/epsilon))=1+Re(1/epsilon) with FFT</span>
            <span class="c1"># Follows: D W Johnson 1975 J. Phys. A: Math. Gen. 8 490</span>
            <span class="c1"># Use an optimal FFT size to speed up the calculation, and</span>
            <span class="c1"># make it double the closest upper value to workaround the</span>
            <span class="c1"># wrap-around problem.</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span><span class="p">)</span>  <span class="c1"># 2**math.floor(math.log2(l)+1)*4</span>
            <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">Im</span><span class="p">,</span> <span class="n">esize</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">esize</span>  <span class="c1"># TODO : min twee?????</span>

            <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="c1"># Final touch, we have Re(1/eps)</span>
            <span class="n">Re</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># TODO: plus 1???</span>
            <span class="c1"># Egerton does this to correct the wrap-around problem, but in our</span>
            <span class="c1"># case this is not necessary because we compute the fft on an</span>
            <span class="c1"># extended and padded spectrum to avoid this problem.</span>
            <span class="c1"># Re=real(q)</span>
            <span class="c1"># Tail correction</span>
            <span class="c1"># vm=Re[axis.size-1]</span>
            <span class="c1"># Re[:(axis.size-1)]=Re[:(axis.size-1)]+1-(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size*2-arange(0,axis.size-1)))**2)</span>
            <span class="c1"># Re[axis.size:]=1+(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size+arange(0,axis.size)))**2)</span>

            <span class="c1"># Epsilon appears:</span>
            <span class="c1">#  We calculate the real and imaginary parts of the CDF</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N_ZLP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># TODO: loop weghalen.</span>
                <span class="c1"># Surface losses correction:</span>
                <span class="c1">#  Calculates the surface ELF from a vaccumm border effect</span>
                <span class="c1">#  A simulated surface plasmon is subtracted from the ELF</span>
                <span class="n">Srfelf</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">e2</span> <span class="o">/</span> <span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Im</span>
                <span class="n">adep</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt</span> <span class="o">/</span> <span class="p">(</span><span class="n">eaxis</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">beta</span> <span class="o">/</span> <span class="mf">1000.</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eaxis</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">tgt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">Srfint</span> <span class="o">=</span> <span class="mi">2000</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">adep</span> <span class="o">*</span> <span class="n">Srfelf</span> <span class="o">/</span> <span class="n">rk0</span> <span class="o">/</span> <span class="n">te</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span>  <span class="c1"># axis.scale</span>
                <span class="k">if</span> <span class="n">correct_S_s</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;correcting S_s&quot;</span><span class="p">)</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span> <span class="o">&gt;</span> <span class="n">S_E</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_E</span><span class="p">[</span><span class="n">Srfint</span> <span class="o">&gt;</span> <span class="n">S_E</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">S_E</span> <span class="o">-</span> <span class="n">Srfint</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Iteration number: </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">io</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>

        <span class="n">eps</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">y</span>
        <span class="k">del</span> <span class="n">I_EELS</span>
        <span class="k">if</span> <span class="s1">&#39;thickness&#39;</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="c1"># As above,prevent errors if the signal is a single spectrum</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span>

        <span class="k">return</span> <span class="n">eps</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">Srfint</span></div>

<div class="viewcode-block" id="SpectralImage.KK_pixel"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.KK_pixel">[docs]</a>    <span class="k">def</span> <span class="nf">KK_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a Kramer-Krönig analysis on pixel (``i``, ``j``).</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        j : int</span>
<span class="sd">            y-coordinate of the pixel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dielectric_functions : array_like</span>
<span class="sd">            Collection dielectric-functions replicas at pixel (``i``, ``j``).</span>
<span class="sd">        ts : float</span>
<span class="sd">            Thickness.</span>
<span class="sd">        S_ss : array_like</span>
<span class="sd">            Surface scatterings.</span>
<span class="sd">        IEELSs : array_like</span>
<span class="sd">            Deconvonluted EELS spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data_ij = self.get_pixel_signal(i,j)#[self.deltaE&gt;0]</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="n">select_ZLPs</span><span class="p">)</span>  <span class="c1"># [:,self.deltaE&gt;0]</span>

        <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">max_ieels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">IEELS</span>
            <span class="n">max_ieels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IEELS</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
                <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span><span class="o">=</span><span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_thickness</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N_ZLP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span><span class="p">,</span> <span class="n">max_ieels</span>

        <span class="n">IEELSs_OG</span> <span class="o">=</span> <span class="n">IEELSs</span>
        <span class="n">ts_OG</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="n">max_OG</span> <span class="o">=</span> <span class="n">max_ieels</span>

        <span class="n">ZLPs_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="n">select_ZLPs</span><span class="o">=</span><span class="n">select_ZLPs</span><span class="p">)</span>
        <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">max_ieels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZLPs_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs_signal</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
            <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">IEELS</span>
            <span class="n">max_ieels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IEELS</span><span class="p">)]</span>
            <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span><span class="o">=</span><span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">ts_OG</span><span class="p">,</span> <span class="n">IEELSs_OG</span><span class="p">,</span> <span class="n">max_OG</span><span class="p">],</span> <span class="p">[</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span><span class="p">,</span> <span class="n">max_ieels</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">optical_absorption_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dielectric_function</span><span class="p">):</span>

        <span class="c1"># TODO: now assuming one input for dielectric function. We could check for dimentions, and do everything at once??</span>

        <span class="n">eps1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dielectric_function</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">mu</span> <span class="o">=</span> <span class="n">E</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_bar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">dielectric_function</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mu</span>

        <span class="k">pass</span>

<div class="viewcode-block" id="SpectralImage.im_dielectric_function"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.im_dielectric_function">[docs]</a>    <span class="k">def</span> <span class="nf">im_dielectric_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track_process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="s2">&quot;KK_analysis&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the dielectric function by performing a Kramer-Krönig analysis at each pixel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        track_process: bool, optional</span>
<span class="sd">            default is `False`, if `True`,  outputs for each pixel the program that is busy with that pixel.</span>
<span class="sd">        plot: bool, optional</span>
<span class="sd">            default is `False`, if `True`, plots all calculated dielectric functions</span>
<span class="sd">        save_index: int, optional</span>
<span class="sd">            optional labelling to incude in ``save_path``.</span>
<span class="sd">        save_path: str, optional</span>
<span class="sd">            location where the dielectric function, SSD and thickness are stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO</span>
        <span class="c1"># data = self.data[self.deltaE&gt;0, :,:]</span>
        <span class="c1"># energies = self.deltaE[self.deltaE&gt;0]</span>
        <span class="c1"># TODO: make check for models</span>
        <span class="c1"># if not hasattr(self, &#39;ZLPs_gen&#39;):</span>
        <span class="c1">#     self.calc_ZLPs_gen2(&quot;iets&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">N_ZLPs_calculated</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;N_ZLPs&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: add N_ZLP saving</span>
        <span class="c1"># if not N_ZLPs_calculated:</span>
        <span class="c1">#    self.N_ZLPs = np.zeros(self.image_shape)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">track_process</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating dielectric function for pixel &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

                <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">KK_pixel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="c1"># print(ts)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_path</span> <span class="o">+=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">save_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="s1">&#39;/&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;diel_fun_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;S_s_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;thickness_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">)</span></div>
        <span class="c1"># return dielectric_function_im_avg, dielectric_function_im_std</span>

    <span class="k">def</span> <span class="nf">optical_absorption_coeff_im</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO!!</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="SpectralImage.crossings_im"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.crossings_im">[docs]</a>    <span class="k">def</span> <span class="nf">crossings_im</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the number of crossings of the real part of dielectric function at all pixels together with the associated</span>
<span class="sd">        ``dE`` values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="n">n_max</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># print(&quot;cross&quot;, i)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># print(&quot;cross&quot;, i, j)</span>
                <span class="n">crossings_E_ij</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>  <span class="c1"># , delta)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">n_max</span><span class="p">:</span>
                    <span class="c1"># print(&quot;cross&quot;, i, j, n, n_max, crossings_E.shape)</span>
                    <span class="n">crossings_E_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">))</span>
                    <span class="c1"># print(&quot;cross&quot;, i, j, n, n_max, crossings_E.shape, crossings_E_new[:,:,:n_max].shape)</span>
                    <span class="n">crossings_E_new</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">n_max</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">crossings_E_new</span>
                    <span class="n">n_max</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">del</span> <span class="n">crossings_E_new</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossings_E_ij</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span></div>

    <span class="k">def</span> <span class="nf">crossings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>  <span class="c1"># , delta = 50):</span>
        <span class="c1"># l = len(die_fun)</span>
        <span class="n">die_fun_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># die_fun_f = np.zeros(l-2*delta)</span>
        <span class="c1"># TODO: use smooth?</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for i in range(self.l-delta):</span>
<span class="sd">            die_fun_avg[i] = np.average(self.dielectric_function_im_avg[i:i+delta])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">deltaE_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># deltaE_n = deltaE_n[50:-50]</span>
        <span class="n">crossing_E</span> <span class="o">=</span> <span class="n">deltaE_n</span><span class="p">[</span><span class="n">crossing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crossing_E</span><span class="p">,</span> <span class="n">n</span>

    <span class="c1"># %%</span>
    <span class="c1"># TODO: add bandgap finding</span>

<div class="viewcode-block" id="SpectralImage.cluster"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clusters the spectral image into clusters according to the (log) integrated intensity at each</span>
<span class="sd">        pixel. Cluster means are stored in the attribute ``self.clusters`` and the index to which each cluster belongs is</span>
<span class="sd">        stored in the attribute ``self.clustered``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters : int, optional</span>
<span class="sd">            Number of clusters, 5 by default</span>
<span class="sd">        based_on : str, optional</span>
<span class="sd">            One can cluster either on the sum of the intensities (pass ````sum````), the log of the sum (pass ````log````) or the thickness (pass ````thickness````).</span>
<span class="sd">            The default is ````log````.</span>
<span class="sd">        **kwargs : keyword arguments</span>
<span class="sd">            additional keyword arguments to pass to :py:meth:`k_means_clustering.k_means() &lt;k_means_clustering.k_means()&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s2">&quot;thickness&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">based_on</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">based_on</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The size of values on which to cluster does not match the image size.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">clusters_unsorted</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">k_means</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arg_sort_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">in_cluster_i</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">arg_sort_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">+=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">in_cluster_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">))</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectralImage.cluster_on_cluster_values"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.cluster_on_cluster_values">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the image has been clustered before and the the cluster means are already known,</span>
<span class="sd">        one can use this function to reconstruct the original clustering of the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_values: array_like</span>
<span class="sd">            Array with the cluster means</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Works only for images clustered on (log) integrated intensity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_values</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">check_log</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cluster_values</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">check_log</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">valar</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">valar</span> <span class="o">-</span> <span class="n">cluster_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;it seems like the clustered values of dE1 are not clustered on this image/on log or sum. Please check clustering.&quot;</span><span class="p">)</span></div>

    <span class="c1"># PLOTTING FUNCTIONS</span>
<div class="viewcode-block" id="SpectralImage.plot_sum"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.plot_sum">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the summation over the intensity for each pixel in a heatmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title: str, optional</span>
<span class="sd">            Title of the plot</span>
<span class="sd">        xlab: str, optional</span>
<span class="sd">            x-label</span>
<span class="sd">        ylab: str, optional</span>
<span class="sd">            y-label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: invert colours</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;intgrated intensity spectrum &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
            <span class="c1">#    plt.xlabel(self.pixelsize)</span>
            <span class="c1">#    plt.ylabel(self.pixelsize)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xticks</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yticks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">xlab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpectralImage.plot_heatmap"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.plot_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="s1">&#39;[</span><span class="se">\u03BC</span><span class="s1">m]&#39;</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="s1">&#39;[</span><span class="se">\u03BC</span><span class="s1">m]&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> 
                     <span class="n">discrete_colormap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sig_cbar</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color_bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equal_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                     <span class="n">sig_ticks</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">npix_xtick</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">npix_ytick</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">scale_ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tick_int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                     <span class="n">save_as</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a heatmap for given data input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array</span>
<span class="sd">            Input data for heatmap, but be 2 dimensional.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Set the title of the heatmap. The default is None.</span>
<span class="sd">        xlab : str, optional</span>
<span class="sd">            Set the label of the x-axis. Micron ([\u03BCm]) are assumed as standard scale. The default is &#39;[\u03BCm]&#39;.</span>
<span class="sd">        ylab : str, optional</span>
<span class="sd">            Set the label of the y-axis. Microns ([\u03BCm]) are assumed as standard scale. The default is &#39;[\u03BCm]&#39;.</span>
<span class="sd">        cmap : str, optional</span>
<span class="sd">            Set the colormap of the heatmap. The default is &#39;coolwarm&#39;.</span>
<span class="sd">        discrete_colormap : bool, optional</span>
<span class="sd">            Enables the heatmap values to be discretised. Best used in conjuction with color_bin_size. The default is False.</span>
<span class="sd">        sig_cbar : int, optional</span>
<span class="sd">            Set the amount of significant numbers displayed in the colorbar. The default is 3.</span>
<span class="sd">        color_bin_size : float, optional</span>
<span class="sd">            Set the size of the bins used for discretisation. Best used in conjuction discrete_colormap. The default is None.</span>
<span class="sd">        equal_axis : bool, optional</span>
<span class="sd">            Enables the pixels to look square or not. The default is True.</span>
<span class="sd">        sig_ticks : int, optional</span>
<span class="sd">            Set the amount of significant numbers displayed in the ticks. The default is 2.</span>
<span class="sd">        npix_xtick : float, optional</span>
<span class="sd">            Display a tick per n pixels in the x-axis. Note that this value can be a float. The default is 10.</span>
<span class="sd">        npix_ytick : float, optional</span>
<span class="sd">            Display a tick per n pixels in the y-axis. Note that this value can be a float. The default is 10.</span>
<span class="sd">        scale_ticks : float, optional</span>
<span class="sd">            Change the scaling of the numbers displayed in the ticks. Microns ([\u03BCm]) are assumed as standard scale, adjust scaling from there. The default is 1.</span>
<span class="sd">        tick_int : bool, optional</span>
<span class="sd">            Set whether you only want the ticks to display as integers instead of floats. The default is False.</span>
<span class="sd">        save_as : str, optional</span>
<span class="sd">            Set the location and name for the heatmap to be saved to. The default is False.</span>
<span class="sd">        **kwargs : dictionary</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># TODO: invert colours</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Mask all True: no values to plot.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">equal_axis</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>

            <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&gt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&lt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="s1">&#39;vmin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&lt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&gt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">color_bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">color_bin_size</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color_bin_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">unique_data_points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">30</span><span class="p">)</span>
                    
            <span class="n">n_colors</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">))</span><span class="o">/</span><span class="n">color_bin_size</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">n_colors</span><span class="p">)</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="n">color_bin_size</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">)</span> <span class="o">+</span> <span class="n">spacing</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">)</span> <span class="o">-</span> <span class="n">spacing</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span><span class="p">,</span> <span class="n">xticks_labels</span><span class="p">,</span> <span class="n">yticks_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">(</span><span class="n">sig_ticks</span><span class="p">,</span> <span class="n">npix_xtick</span><span class="p">,</span> <span class="n">npix_ytick</span><span class="p">,</span> <span class="n">scale_ticks</span><span class="p">,</span> <span class="n">tick_int</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">xticks</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">yticks</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">xticks_labels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">yticks_labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        
        <span class="n">colorbar</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">colorbar</span>
        <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>    
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]))</span>
                <span class="n">cbar_ticks_labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">tick</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">cbar_ticks_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">round_scientific</span><span class="p">(</span><span class="n">tick</span><span class="p">,</span> <span class="n">sig_cbar</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tick</span><span class="p">)))))))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cbar_ticks_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">round_scientific</span><span class="p">(</span><span class="n">tick</span><span class="p">,</span> <span class="n">sig_cbar</span><span class="p">))</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">cbar_ticks_labels</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="s1">&#39;vmin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]:</span>
                <span class="n">cbar_ticks</span> <span class="o">=</span> <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticks</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spacing</span><span class="p">))</span>
                <span class="n">cbar_ticks</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\leq$&#39;</span> <span class="o">+</span> <span class="n">cbar_ticks</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">cbar_ticks</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]:</span>
                <span class="n">cbar_ticks</span> <span class="o">=</span> <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">()</span>
                <span class="n">cbar_ticks_values</span> <span class="o">=</span> <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticks</span><span class="p">()</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cbar_ticks_values</span> <span class="o">&lt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">spacing</span><span class="p">))</span>
                <span class="n">cbar_ticks</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\geq$&#39;</span> <span class="o">+</span> <span class="n">cbar_ticks</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">cbar_ticks</span><span class="p">)</span>                

        <span class="k">if</span> <span class="n">save_as</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">save_as</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
                    <span class="n">save_as</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">save_as</span> <span class="o">+=</span> <span class="s1">&#39;_masked&#39;</span>
            <span class="n">save_as</span> <span class="o">+=</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_as</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
 
    
<div class="viewcode-block" id="SpectralImage.get_ticks"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.get_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">get_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_ticks</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">npix_xtick</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">npix_ytick</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">scale_ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tick_int</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the proper tick labels and tick positions for the heatmap plots.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_ticks : int, optional</span>
<span class="sd">            Set the amount of significant numbers displayed in the ticks. The default is 2.</span>
<span class="sd">        npix_xtick : float, optional</span>
<span class="sd">            Display a tick per n pixels in the x-axis. Note that this value can be a float. The default is 10.</span>
<span class="sd">        npix_ytick : float, optional</span>
<span class="sd">            Display a tick per n pixels in the y-axis. Note that this value can be a float. The default is 10.</span>
<span class="sd">        scale_ticks : float, optional</span>
<span class="sd">            Change the scaling of the numbers displayed in the ticks. Microns ([\u03BCm]) are assumed as standard scale, adjust scaling from there. The default is 1.</span>
<span class="sd">        tick_int : bool, optional</span>
<span class="sd">            Set whether you only want the ticks to display as integers instead of floats. The default is False.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xticks : array_like</span>
<span class="sd">            Array of the xticks positions.</span>
<span class="sd">        yticks : array_like</span>
<span class="sd">            Array of the yticks positions.</span>
<span class="sd">        xticks_labels : array_like</span>
<span class="sd">            Array with strings of the xtick labels.</span>
<span class="sd">        yticks_labels : array_like</span>
<span class="sd">            Array with strings of the ytick labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">xticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npix_xtick</span><span class="p">)</span>
        <span class="n">yticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npix_ytick</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">tick_int</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">xticks_labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">xticks</span> <span class="o">*</span> <span class="n">round_scientific</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_ticks</span><span class="p">,</span> <span class="n">sig_ticks</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">yticks_labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">yticks</span> <span class="o">*</span> <span class="n">round_scientific</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_ticks</span><span class="p">,</span> <span class="n">sig_ticks</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xticks_labels</span> <span class="o">=</span> <span class="n">trunc</span><span class="p">(</span><span class="n">xticks</span> <span class="o">*</span> <span class="n">round_scientific</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_ticks</span><span class="p">,</span> <span class="n">sig_ticks</span><span class="p">),</span> <span class="n">sig_ticks</span><span class="p">)</span>
            <span class="n">yticks_labels</span> <span class="o">=</span> <span class="n">trunc</span><span class="p">(</span><span class="n">yticks</span> <span class="o">*</span> <span class="n">round_scientific</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_ticks</span><span class="p">,</span> <span class="n">sig_ticks</span><span class="p">),</span> <span class="n">sig_ticks</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span><span class="p">,</span> <span class="n">xticks_labels</span><span class="p">,</span> <span class="n">yticks_labels</span></div>

    <span class="k">def</span> <span class="nf">plot_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_image</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">range_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s2">&quot;EELS&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># TODO: add titles and such</span>
        <span class="k">if</span> <span class="n">range_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">range_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">same_image</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Spectrum image &quot;</span> <span class="o">+</span> <span class="n">signal</span> <span class="o">+</span> <span class="s2">&quot; spectra&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[eV]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">same_image</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Spectrum pixel: [&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[eV]&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">signal_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log intensity&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">signal_pixel</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="c1"># GENERAL FUNCTIONS</span>
    <span class="k">def</span> <span class="nf">get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;data&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;ieels&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;zlp&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;eps&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">THICKNESS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;thickness&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>

    <span class="c1"># STATIC METHODS</span>
<div class="viewcode-block" id="SpectralImage.get_prefix"><a class="viewcode-back" href="../modules/modules.html#spectral_image.SpectralImage.get_prefix">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_prefix</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">SIunit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to convert units to their associated SI values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        unit: str,</span>
<span class="sd">            unit of which the prefix is requested</span>
<span class="sd">        SIunit: str, optional</span>
<span class="sd">            The SI unit of the unit</span>
<span class="sd">        numeric: bool, optional</span>
<span class="sd">            Default is `True`. If `True` the prefix is translated to the numeric value</span>
<span class="sd">            (e.g. :math:`10^3` for `k`)</span>


<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        prefix: str or int</span>
<span class="sd">            The character of the prefix or the numeric value of the prefix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">SIunit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lenSI</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SIunit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">[</span><span class="o">-</span><span class="n">lenSI</span><span class="p">:]</span> <span class="o">==</span> <span class="n">SIunit</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[:</span><span class="o">-</span><span class="n">lenSI</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">prefix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provided unit not same as target unit: &quot;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">&quot;, and &quot;</span> <span class="o">+</span> <span class="n">SIunit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO: is this correct? JTH 01/07</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prefix</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-12</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;μ&#39;</span><span class="p">,</span> <span class="s1">&#39;µ&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;micron&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mf">1E-6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E12</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;either no or unknown prefix in unit: &quot;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">&quot;, found prefix &quot;</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;, asuming no.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_avg_ci</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">return_low_high</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_low_high</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_low</span><span class="p">,</span> <span class="n">ci_high</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_high</span> <span class="o">-</span> <span class="n">ci_low</span>

    <span class="c1"># CLASS THINGIES</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determines behavior of `self[key]` &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># pass</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;Spectral image: &#39;</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;, image size:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;x&#39;</span> <span class="o">+</span> \
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;, deltaE range: [&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> \
               <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;], deltadeltaE: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data_str</span> <span class="o">=</span> <span class="s2">&quot;data * np.ones(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Spectral_image(&quot;</span> <span class="o">+</span> <span class="n">data_str</span> <span class="o">+</span> <span class="s2">&quot;, deltadeltaE=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span></div>


<span class="c1"># GENERAL DATA MODIFICATION FUNCTIONS  </span>

<span class="k">def</span> <span class="nf">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta_x</span>  <span class="c1"># np.exp(-1j*(x_0)*k*delta_omg)*delta_x</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">cont_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F_k</span>


<span class="k">def</span> <span class="nf">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Y_k</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">cont_factor</span> <span class="o">*</span> <span class="n">Y_k</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_x</span>
    <span class="k">return</span> <span class="n">f_n</span>


<span class="k">def</span> <span class="nf">smooth_1D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the begining and end part of the output signal.</span>

<span class="sd">    input:</span>
<span class="sd">        x: the input signal </span>
<span class="sd">        window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">        window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;</span>
<span class="sd">            flat window will produce a moving average smoothing.</span>

<span class="sd">    output:</span>
<span class="sd">        the smoothed signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add comnparison</span>
    <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;-1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>  <span class="c1"># moving average</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">window</span> <span class="o">+</span> <span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

    <span class="c1"># y=np.convolve(w/w.sum(),s,mode=&#39;valid&#39;)</span>
    <span class="c1"># return y[(window_len-1):-(window_len)]</span>
    <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span>
           <span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="c1"># MODELING CLASSES AND FUNCTIONS</span>
<span class="k">def</span> <span class="nf">bandgap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">BG</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">amp</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">BG</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Initialize the modules we need to build the network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Perform the calculation of the model to determine the prediction</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    min_inp = inp.min()</span>
<span class="sd">    max_inp = inp.max()</span>
<span class="sd">    </span>
<span class="sd">    outp = inp/(max_inp-min_inp) * (max_out-min_out)</span>
<span class="sd">    outp -= outp.min()</span>
<span class="sd">    outp += min_out</span>
<span class="sd">    </span>
<span class="sd">    return outp</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">inp</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># pass</span>


<span class="k">def</span> <span class="nf">find_scale_var</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">min_out</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_out</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_out</span> <span class="o">-</span> <span class="n">min_out</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">min_out</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">round_scientific</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span> <span class="o">-</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num</span>

<span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">decs</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">values</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">decs</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">decs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">round_to_nearest</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">base</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">base</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, A

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>