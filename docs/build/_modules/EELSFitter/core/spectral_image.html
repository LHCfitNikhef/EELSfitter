

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EELSFitter.core.spectral_image &mdash; EELSFitter 3.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=6f954d08" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=dd1205ac"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EELSFitter
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/instructions.html">Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/eelsfitter_tutorial.html">EELSfitter tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/cluster.html">Training models in parallel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/clustering_pooling.html">Pooling and clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/nn_training.html">NN training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/kk_analysis.html">Kramers-Kronig analysis of EEL spectra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/band_gap_analysis.html">Band gap analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Key Results</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../key_results/Roest2021.html">Charting the low-loss region in Electron Energy Loss Spectroscopy with machine learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../key_results/vanHeijst2021.html">Illuminating the Electronic Properties of WS<sub>2</sub> Polytypism with Electron Microscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../key_results/Brokkelkamp2022.html">Spatially-resolved band gap and dielectric function in 2D materials from Electron Energy Loss Spectroscopy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../key_results/vanderLippe2023.html">Localized exciton anatomy and band gap energy modulation in 1D MoS<sub>2</sub> nanostructures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../key_results/La2023.html">Edge-induced excitations in Bi<sub>2</sub>Te<sub>3</sub> from spatially-resolved electron energy-gain spectroscopy</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/EELSFitter.html">EELSFitter package</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EELSFitter</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">EELSFitter.core.spectral_image</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for EELSFitter.core.spectral_image</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">_pickle</span> <span class="k">as</span> <span class="nn">cPickle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">ncempy.io</span> <span class="k">as</span> <span class="nn">nio</span>

<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">next_fast_len</span><span class="p">,</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span><span class="p">,</span> <span class="n">NMF</span>
<span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GaussianMixture</span>

<span class="kn">from</span> <span class="nn">.training</span> <span class="kn">import</span> <span class="n">MultilayerPerceptron</span><span class="p">,</span> <span class="n">TrainZeroLossPeak</span>
<span class="kn">from</span> <span class="nn">..plotting.training_perf</span> <span class="kn">import</span> <span class="n">plot_cost_dist</span>
<span class="kn">from</span> <span class="nn">..plotting.zlp</span> <span class="kn">import</span> <span class="n">plot_zlp_cluster_predictions</span>
<span class="kn">from</span> <span class="nn">..plotting.mva_perf</span> <span class="kn">import</span> <span class="n">plot_pca_variance</span>

<span class="c1"># Where is this used?</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>  <span class="c1"># pyplot style</span>

<span class="c1"># Where is this used?</span>
<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ProcessSpectralImage</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Load spectral image.</span>

<span class="sd">        ARGUMENTS</span>
<span class="sd">        ---------</span>
<span class="sd">            image (dm4): spectral image.</span>

<span class="sd">        EXAMPLE</span>
<span class="sd">        -------</span>
<span class="sd">        processed_SI = ProcessSpectralImage(image=img)</span>
<span class="sd">        processed_SI.save_spectra_in_3D_array()</span>
<span class="sd">        processed_SI.self.center_ZLP_at_0eV()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_signal</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">eaxis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">save_3D_arrays_in_4D_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_aisles</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span>
        <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE_shifted</span>
        <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_signal</span>
        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">save_spectra_in_3D_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_aisles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 3D array: (row, column, aisle)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_zeroes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_aisles</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr3D_zeroes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr3D_zeroes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">):</span>
                <span class="c1"># save the deltaE in aisle of 3D array</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_signal</span>
                <span class="c1"># save the signal in aisle of 3D array</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_signal</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">center_ZLP_at_0eV</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Take maximum of ZLP, determine its median and shift ZLP to 0 eV.&quot;&quot;&quot;</span>
        <span class="c1"># get index of max value for each aisle</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_signal</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># get the shifted energy per aisle, i.e. per (row,col)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr2D_shifted_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span><span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

        <span class="c1"># create 3D array of shifted energy</span>
        <span class="n">arr3D_shifted_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arr3D_zeroes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_aisles</span><span class="p">):</span>
            <span class="c1"># fill each layer with the same 2D array containing shifted energy</span>
            <span class="n">arr3D_shifted_E</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr2D_shifted_E</span>

        <span class="c1"># subtract each aisle by the corresponding shifted energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE_shifted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span> <span class="o">-</span> <span class="n">arr3D_shifted_E</span>

    <span class="k">def</span> <span class="nf">check_if_ZLP_centered_at_0eV_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE</span>
        <span class="n">xS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_deltaE_shifted</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr3D_signal</span>
        <span class="c1"># plot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">):</span>
            <span class="c1"># plot each spectrum</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x0</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y0</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="c1"># plot each spectrum (shifted)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xS</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y0</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span>

    <span class="k">def</span> <span class="nf">plot_spectral_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo_r&#39;</span><span class="p">,</span> <span class="n">cbar_title</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">cbar_title</span><span class="p">)</span>  <span class="c1"># intensity lower for thicker sample</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>


<div class="viewcode-block" id="SpectralImage">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage">[docs]</a>
<span class="k">class</span> <span class="nc">SpectralImage</span><span class="p">:</span>
    <span class="c1">#  signal names</span>
    <span class="n">DIELECTRIC_FUNCTION_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dielectric_function&#39;</span><span class="p">,</span> <span class="s1">&#39;dielectricfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;dielec_func&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;die_fun&#39;</span><span class="p">,</span> <span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">]</span>
    <span class="n">EELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;electron_energy_loss_spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;electron_energy_loss&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="s1">&#39;EEL&#39;</span><span class="p">,</span> <span class="s1">&#39;energy_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">IEELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inelastic_scattering_energy_loss_spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;inelastic_scattering_energy_loss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;inelastic_scattering&#39;</span><span class="p">,</span> <span class="s1">&#39;IEELS&#39;</span><span class="p">,</span> <span class="s1">&#39;IES&#39;</span><span class="p">,</span> <span class="s1">&#39;signal_scattering_distribution&#39;</span><span class="p">,</span> <span class="s1">&#39;ssd&#39;</span><span class="p">]</span>
    <span class="n">ZLP_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;zeros_loss_peak&#39;</span><span class="p">,</span> <span class="s1">&#39;zero_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLP&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLPs&#39;</span><span class="p">,</span> <span class="s1">&#39;zlp&#39;</span><span class="p">,</span> <span class="s1">&#39;zlps&#39;</span><span class="p">]</span>
    <span class="n">THICKNESS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;thick&#39;</span><span class="p">,</span> <span class="s1">&#39;thin&#39;</span><span class="p">]</span>
    <span class="n">POOLED_ADDITION</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;pool&#39;</span><span class="p">,</span> <span class="s1">&#39;_pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;_pool&#39;</span><span class="p">]</span>
    <span class="n">PCA_ADDITION</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">,</span> <span class="s1">&#39;PCA&#39;</span><span class="p">,</span> <span class="s1">&#39;_pca&#39;</span><span class="p">,</span> <span class="s1">&#39;_PCA&#39;</span><span class="p">]</span>
    <span class="n">NMF_ADDITION</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nmf&#39;</span><span class="p">,</span> <span class="s1">&#39;NMF&#39;</span><span class="p">,</span> <span class="s1">&#39;_nmf&#39;</span><span class="p">,</span> <span class="s1">&#39;_NMF&#39;</span><span class="p">]</span>

    <span class="c1"># meta data names</span>
    <span class="n">COLLECTION_ANGLE_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;collection_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;col_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]</span>
    <span class="n">CONVERGENCE_ANGLE_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;convergence_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;con_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">]</span>
    <span class="n">BEAM_ENERGY_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;beam_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;beam_E&quot;</span><span class="p">,</span> <span class="s2">&quot;E_beam&quot;</span><span class="p">,</span> <span class="s2">&quot;E0&quot;</span><span class="p">,</span> <span class="s2">&quot;E_0&quot;</span><span class="p">,</span> <span class="s2">&quot;e0&quot;</span><span class="p">,</span> <span class="s2">&quot;e_0&quot;</span><span class="p">]</span>

    <span class="c1"># Global physical constants</span>
    <span class="n">m_e</span> <span class="o">=</span> <span class="mf">5.1106E5</span>  <span class="c1"># [eV],     Electron rest mass</span>
    <span class="n">e_c</span> <span class="o">=</span> <span class="mf">1.602176487E-19</span>  <span class="c1"># [C],      Electron charge</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="mf">5.29E-11</span>  <span class="c1"># [m],      Bohr radius</span>
    <span class="n">h_bar</span> <span class="o">=</span> <span class="mf">6.582119569E-16</span>  <span class="c1"># [eV*s],   Planck&#39;s constant</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.99792458E8</span>  <span class="c1"># [m/s],    Speed of light</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">deltaE</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beam_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">collection_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convergence_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The spectral image class that provides several tools to analyse spectral images with the zero-loss peak</span>
<span class="sd">        subtracted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: numpy.ndarray, shape=(M,N,L)</span>
<span class="sd">            Array containing the 3-D spectral image. The axes correspond to the x-axis (M), y-axis (N) and energy-loss (L).</span>
<span class="sd">        deltaE: float, optional</span>
<span class="sd">            bin width in energy loss spectrum in eV</span>
<span class="sd">        pixel_size: numpy.ndarray, shape=(2,), optional</span>
<span class="sd">            width of pixels in nm</span>
<span class="sd">        beam_energy: float, optional</span>
<span class="sd">            Energy of electron beam in KeV</span>
<span class="sd">        collection_angle: float, optional</span>
<span class="sd">            Collection angle of STEM in mrad</span>
<span class="sd">        convergence_angle: float, optional</span>
<span class="sd">            Convergence angle of STEM in mrad</span>
<span class="sd">        name: str, optional</span>
<span class="sd">            Name of the SI data file</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        An example how to train and analyse a spectral image::</span>

<span class="sd">            path_to_image = &#39;path to dm4 file&#39;</span>
<span class="sd">            im = SpectralImage.load_data(path_to_image)</span>
<span class="sd">            im.train_zlp_models(n_clusters=8,</span>
<span class="sd">                                n_rep=100,</span>
<span class="sd">                                n_epochs=150000,</span>
<span class="sd">                                bs_rep_num=1,</span>
<span class="sd">                                path_to_models=path_to_models)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Image properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="n">deltaE</span>  <span class="c1"># eV, energy bin width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_eaxis</span><span class="p">()</span>  <span class="c1"># Sets the shifted energy axis (E = 0 corresponds to peak of ZLP)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span> <span class="o">=</span> <span class="n">pixel_size</span>  <span class="c1"># nm, real world size of the pixel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_axes</span><span class="p">()</span>  <span class="c1"># Calculates the x and y-axis based on the pixel size.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">=</span> <span class="n">beam_energy</span>  <span class="c1"># KeV, incoming beam energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="o">=</span> <span class="n">collection_angle</span>  <span class="c1"># mrad, collection semi-angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_angle</span> <span class="o">=</span> <span class="n">convergence_angle</span>  <span class="c1"># mrad, convergence semi-angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># SI name</span>

        <span class="c1"># ZLP models properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Center values of the clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 2d array where each pixel location has a corresponding cluster label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_signals</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># All signals collected per cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_eaxis</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">)</span>  <span class="c1"># scale variables for the energy axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_int_i</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># scale variables for the log of the integrated intensities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dE1 hyperparameter for each cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE2</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># dE2 hyperparameter for each cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FWHM</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Full Width at Half Maximum for each cluster</span>

        <span class="c1"># Additional image properties for calculations and data modification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SI data is enhanced by pooling a pixel with surrounding pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_pca</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SI data is enhanced by performing PCA on the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_nmf</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SI data is enhanced by performing NMF on the data</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Refractive index, set per cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Mass density, set per cluster</span>


        <span class="c1"># Other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

    <span class="c1"># PROPERTIES</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns 3D-shape of</span>
<span class="sd">        :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of spectra present in</span>
<span class="sd">        :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of clusters in the</span>
<span class="sd">        :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">)</span>

    <span class="c1"># METHODS ON SAVING AND LOADING DATA</span>
<div class="viewcode-block" id="SpectralImage.load_dmfile">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.load_dmfile">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_dmfile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_dmfile</span><span class="p">,</span> <span class="n">load_survey_data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the .dm4 (or .dm3) data and return a</span>
<span class="sd">        :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_dmfile: str</span>
<span class="sd">            location of .dm4 file</span>
<span class="sd">        load_survey_data: bool, optional</span>
<span class="sd">            If there is HAADF survey data in your file, you can choose to also load that in. Default is `False`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectralImage</span>
<span class="sd">            :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;`</span>
<span class="sd">            instance of the dm4 file</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dmfile</span> <span class="o">=</span> <span class="n">nio</span><span class="o">.</span><span class="n">dm</span><span class="o">.</span><span class="n">fileDM</span><span class="p">(</span><span class="n">path_to_dmfile</span><span class="p">)</span>

        <span class="n">dmobjects</span> <span class="o">=</span> <span class="n">dmfile</span><span class="o">.</span><span class="n">numObjects</span>
        <span class="n">eels_dict</span> <span class="o">=</span> <span class="n">dmfile</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">dmobjects</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">eels_metadict</span> <span class="o">=</span> <span class="n">dmfile</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">(</span><span class="n">dmobjects</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">eels_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">eels_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># A single signal is constructed to be a 1 by 1 pixel spectral image.</span>
            <span class="n">eels_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])))</span>
            <span class="n">eels_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dimensions of the data set could not be determined, please check your dataset&quot;</span><span class="p">)</span>

        <span class="c1"># eels data</span>
        <span class="k">if</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">deltaE</span> <span class="o">=</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;deltaE is not found, assuming to be in 1. Otherwise adjust manually&quot;</span><span class="p">)</span>
                <span class="n">deltaE</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pixel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pixel_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pixel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pixel_size is not found, assuming to be 1. Otherwise adjust manually&quot;</span><span class="p">)</span>
                <span class="n">pixel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dm4 metadata does not contain &#39;pixelSize&#39;. deltaE and pixel_size needs to be manually set.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">energy_unit</span> <span class="o">=</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;energy_unit is not found, assuming to be in eV. Otherwise adjust manually&quot;</span><span class="p">)</span>
                <span class="n">deltaE</span> <span class="o">=</span> <span class="s1">&#39;eV&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pixel_unit</span> <span class="o">=</span> <span class="n">eels_dict</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pixel_unit is not found, assuming to be in nanometer. Otherwise adjust manually&quot;</span><span class="p">)</span>
                <span class="n">pixel_unit</span> <span class="o">=</span> <span class="s1">&#39;nm&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dm4 metadata does not contain &#39;pixelUnit&#39;. energy_unit and pixel_unit needs to be manually set&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">energy_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">deltaE</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">deltaE</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">energy_unit</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pixel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pixel_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">pixel_size</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">pixel_unit</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1E9</span>

        <span class="c1"># eels metadata</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">beam_energy</span> <span class="o">=</span> <span class="n">eels_metadict</span><span class="p">[</span><span class="s1">&#39;Microscope Info Voltage&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1E3</span>  <span class="c1"># convert the beam energy to KeV</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">beam_energy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dm4 metadata does not contain &#39;Microscope Info Voltage&#39;. beam_energy needs to be manually set.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">collection_angle</span> <span class="o">=</span> <span class="n">eels_metadict</span><span class="p">[</span><span class="s1">&#39;EELS Experimental Conditions Collection semi-angle (mrad)&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">collection_angle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dm4 metadata does not contain &#39;EELS Experimental Conditions Collection semi-angle (mrad)&#39;. &quot;</span>
                  <span class="s2">&quot;collection_angle needs to be manually set.&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">convergence_angle</span> <span class="o">=</span> <span class="n">eels_metadict</span><span class="p">[</span><span class="s1">&#39;EELS Experimental Conditions Convergence semi-angle (mrad)&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">convergence_angle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dm4 metadata does not contain &#39;EELS Experimental Conditions Convergence semi-angle (mrad)&#39;. &quot;</span>
                  <span class="s2">&quot;convergence_angle needs to be manually set.&quot;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">eels_data</span><span class="p">,</span> <span class="n">deltaE</span><span class="o">=</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span> <span class="n">beam_energy</span><span class="o">=</span><span class="n">beam_energy</span><span class="p">,</span>
                    <span class="n">collection_angle</span><span class="o">=</span><span class="n">collection_angle</span><span class="p">,</span> <span class="n">convergence_angle</span><span class="o">=</span><span class="n">convergence_angle</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">path_to_dmfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>

        <span class="c1"># load in survey data if available</span>
        <span class="k">if</span> <span class="n">dmobjects</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">load_survey_data</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">survey_data</span> <span class="o">=</span> <span class="n">dmfile</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">image</span><span class="o">.</span><span class="n">survey_metadata</span> <span class="o">=</span> <span class="n">dmfile</span><span class="o">.</span><span class="n">getMetadata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="SpectralImage.load_spectral_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.load_spectral_image">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_pickle</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` instance</span>
<span class="sd">        from a pickled file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_pickle : str</span>
<span class="sd">            path to the pickled image file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If path_to_pickle does not end on the desired format .pkl.</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If path_to_pickle does not exist.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectralImage</span>
<span class="sd">            :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` object</span>
<span class="sd">            (i.e. including all attributes) loaded from pickle file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path_to_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;please provide a path to a pickle file containing a Spectral_image class object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="s2">&quot;pickled file: &quot;</span> <span class="o">+</span> <span class="n">path_to_pickle</span> <span class="o">+</span> <span class="s2">&quot; not found&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickle_im</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pickle_im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="SpectralImage.load_compressed_Spectral_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.load_compressed_Spectral_image">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_compressed_Spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_compressed_pickle</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads spectral image from a compressed pickled file. This will take longer than loading from non-compressed</span>
<span class="sd">        pickle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_compressed_pickle : str</span>
<span class="sd">            path to the compressed pickle image file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If path_to_compressed_pickle does not end on the desired format .pbz2.</span>
<span class="sd">        FileNotFoundError</span>
<span class="sd">            If path_to_compressed_pickle does not exist.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : SpectralImage</span>
<span class="sd">             :py:meth:`spectral_image.SpectralImage &lt;EELSFitter.core.spectral_image.SpectralImage&gt;` instance</span>
<span class="sd">             loaded from the compressed pickle file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path_to_compressed_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;please provide a path to a compressed .pbz2 pickle file containing a Spectrall_image class object.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_compressed_pickle</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="s1">&#39;pickled file: &#39;</span> <span class="o">+</span> <span class="n">path_to_compressed_pickle</span> <span class="o">+</span> <span class="s1">&#39; not found&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">decompress_pickle</span><span class="p">(</span><span class="n">path_to_compressed_pickle</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>


<div class="viewcode-block" id="SpectralImage.save_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.save_image">[docs]</a>
    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save image, including all attributes, in pickle (.pkl) format. Image will be saved \</span>
<span class="sd">        at indicated location and name in filename input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            path to save location plus filename. If it does not end on &quot;.pkl&quot;, &quot;.pkl&quot; will be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>  <span class="c1"># Overwrites any existing file.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.save_compressed_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.save_compressed_image">[docs]</a>
    <span class="k">def</span> <span class="nf">save_compressed_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save image, including all attributes, in compressed pickle (.pbz2) format. Image will \</span>
<span class="sd">            be saved at location ``filename``.</span>
<span class="sd">            Advantage over :py:meth:`save_image() &lt;EELSFitter.core.spectral_image.SpectralImage.save_image&gt;` is that \</span>
<span class="sd">            the saved file has a reduced file size, disadvantage is that saving and reloading the image \</span>
<span class="sd">            takes significantly longer.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            path to save location plus filename. If it does not end on &quot;.pbz2&quot;, &quot;.pbz2&quot; will be added.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;.pbz2&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.compressed_pickle">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.compressed_pickle">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compressed_pickle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves ``data`` at location ``title`` as compressed pickle.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.decompress_pickle">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.decompress_pickle">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decompress_pickle</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens, decompresses and returns the pickle file at location ``file``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file: str</span>
<span class="sd">            location where the pickle file is stored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: SpectralImage</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="SpectralImage.get_prefix">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_prefix">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_prefix</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">SIunit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to convert units to their associated SI values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit: str,</span>
<span class="sd">            unit of which the prefix is requested</span>
<span class="sd">        SIunit: str, optional</span>
<span class="sd">            The SI unit of the unit</span>
<span class="sd">        numeric: bool, optional</span>
<span class="sd">            Default is `True`. If `True` the prefix is translated to the</span>
<span class="sd">            numeric value (e.g. :math:`10^3` for `k`)</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        prefix: str or int</span>
<span class="sd">            The character of the prefix or the numeric value of the prefix</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">SIunit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lenSI</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SIunit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">[</span><span class="o">-</span><span class="n">lenSI</span><span class="p">:]</span> <span class="o">==</span> <span class="n">SIunit</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[:</span><span class="o">-</span><span class="n">lenSI</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">prefix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provided unit not same as target unit: &quot;</span> <span class="o">+</span>
                      <span class="n">unit</span> <span class="o">+</span> <span class="s2">&quot;, and &quot;</span> <span class="o">+</span> <span class="n">SIunit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prefix</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-12</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;micron&#39;</span><span class="p">,</span> <span class="s1">&#39;µ&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mf">1E-6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E12</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;either no or unknown prefix in unit: &quot;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span>
                  <span class="s2">&quot;, found prefix &quot;</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;, asuming no.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span></div>


    <span class="c1"># METHODS ON IMAGE</span>
<div class="viewcode-block" id="SpectralImage.set_eaxis">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.set_eaxis">[docs]</a>
    <span class="k">def</span> <span class="nf">set_eaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the energy losses of the spectral image, based on the bin</span>
<span class="sd">        width of the energy loss. It shifts the ``self.eaxis`` attribute such</span>
<span class="sd">        that the zero point corresponds with the point of the highest intensity.</span>

<span class="sd">        It also set the extrapolated eaxis for calculations that require extrapolation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eaxis: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Array of :math:`\Delta E` values</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data_avg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ind_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ind_max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">esize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">esize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">esize</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.calc_axes">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.calc_axes">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the x_axis and y_axis of the spectral image. Stores them in</span>
<span class="sd">        ``self.x_axis`` and ``self.y_axis`` respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpectralImage.get_pixel_signal">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_pixel_signal">[docs]</a>
    <span class="k">def</span> <span class="nf">get_pixel_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the spectrum at pixel (``i``, ``j``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        j: int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        signal_type: str, optional</span>
<span class="sd">            The type of signal that is requested, should comply with the defined</span>
<span class="sd">            names. Set to `EELS` by default.</span>
<span class="sd">        subtract_zlps: bool, optional</span>
<span class="sd">            If `True`, subtract the zlps from the signal, only possible if zlp models are available. Note that the</span>
<span class="sd">            median will be taken from the zlps. Set to `False` by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signal : numpy.ndarray, shape=(M,)</span>
<span class="sd">            Array with the requested signal from the requested pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;EELS&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_nmf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;deconv&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;subtract&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Either no such signal or the signal shape has not been calculated yet, &quot;</span>
                  <span class="s2">&quot;returned general EELS signal.&quot;</span><span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="SpectralImage.get_image_signals">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_image_signals">[docs]</a>
    <span class="k">def</span> <span class="nf">get_image_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the signals of the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal_type: str, optional</span>
<span class="sd">            Description of signal, ``&#39;EELS&#39;`` by default.</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image_signals : numpy.ndarray, shape=(M,N)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;EELS&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_pca</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_nmf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;deconv&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deconvoluted image not available, calculating now, this might take a while&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deconv_image</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deconvolution done!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_pca</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv_nmf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;subtract&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Subtracted image not available, calculating now, this might take a while&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subtract_image</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Subtraction done!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POOLED_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PCA_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_pca</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">signal_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">NMF_ADDITION</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub_nmf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Either no such signal or the signal shape has not been calculated yet, &quot;</span>
                  <span class="s2">&quot;returned general EELS signal.&quot;</span><span class="p">)</span>
            <span class="n">image_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image_signals</span></div>


<div class="viewcode-block" id="SpectralImage.get_cluster_signals">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_cluster_signals">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cluster_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the signals ordered per cluster. Cluster signals are stored in attribute ``self.cluster_signals``.</span>
<span class="sd">        Note that the pixel location information is lost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conf_interval : float, optional</span>
<span class="sd">            The ratio of spectra returned. The spectra are selected based on the </span>
<span class="sd">            based_on value. The default is 1.</span>
<span class="sd">        signal_type: str, optional</span>
<span class="sd">            Description of signal, ``&#39;EELS&#39;`` by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_signals : numpy.ndarray, shape=(M,)</span>
<span class="sd">            An array with size equal to the number of clusters. Each entry is a</span>
<span class="sd">            2D array that contains all the spectra within that cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">integrated_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cluster_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">cluster_signal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">conf_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">intensities_cluster</span> <span class="o">=</span> <span class="n">integrated_int</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">arg_sort_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">intensities_cluster</span><span class="p">)</span>
                <span class="n">ci_lim</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">conf_interval</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span>
                               <span class="n">intensities_cluster</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">cluster_signal</span> <span class="o">=</span> <span class="n">cluster_signal</span><span class="p">[</span><span class="n">arg_sort_int</span><span class="p">][</span><span class="n">ci_lim</span><span class="p">:</span><span class="o">-</span><span class="n">ci_lim</span><span class="p">]</span>
            <span class="n">cluster_signals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_signal</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_signals</span> <span class="o">=</span> <span class="n">cluster_signals</span>
        <span class="k">return</span> <span class="n">cluster_signals</span></div>


<div class="viewcode-block" id="SpectralImage.cut_image_energy">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.cut_image_energy">[docs]</a>
    <span class="k">def</span> <span class="nf">cut_image_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cuts the spectral image at ``E1`` and ``E2`` and keeps only the part in between.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        e1 : float, optional</span>
<span class="sd">            lower cut. The default is ``None``, which means no cut is applied.</span>
<span class="sd">        e2 : float, optional</span>
<span class="sd">            upper cut. The default is ``None``, which means no cut is applied.</span>
<span class="sd">        include_edge : Boolean, optional</span>
<span class="sd">            If True, the edge values given in ``E1`` and ``E2`` are included in the cut result. Default is True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">e2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;To cut energy spectra, please specify minimum energy E1 and/or</span><span class="se">\</span>
<span class="s2">                    maximum energy E2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">e2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">include_edge</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;=</span> <span class="n">e1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">e2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">select</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">select</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpectralImage.cut_image_pixels">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.cut_image_pixels">[docs]</a>
    <span class="k">def</span> <span class="nf">cut_image_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_width</span><span class="p">,</span> <span class="n">range_height</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cuts the spectral image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        range_width: numpy.ndarray, shape=(2,)</span>
<span class="sd">            Contains the horizontal selection cut</span>
<span class="sd">        range_height: numpy.ndarray, shape=(2,)</span>
<span class="sd">            Contains the vertical selection cut</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>


<div class="viewcode-block" id="SpectralImage.deconv_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.deconv_image">[docs]</a>
    <span class="k">def</span> <span class="nf">deconv_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deconvolute the signals of all pixels. Only the median value of the ZLP models is taken.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_deconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start deconvolution&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">)</span>
                <span class="n">zlp_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_matched_zlp_models</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                    <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">data_deconv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolution</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">zlp_median</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;row &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_deconv</span> <span class="o">=</span> <span class="n">data_deconv</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished deconvolution&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_data</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_path</span> <span class="o">+</span> <span class="s1">&#39;data_deconv.npy&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data_deconv</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.subtract_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.subtract_image">[docs]</a>
    <span class="k">def</span> <span class="nf">subtract_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract the ZLP from the signals of all pixels. Only the median value of the ZLP models is taken.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_zlpsub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start subtraction&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">)</span>
                <span class="n">zlp_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_matched_zlp_models</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                    <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">data_zlpsub</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtract_zlp</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">zlp_median</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;row &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span> <span class="o">=</span> <span class="n">data_zlpsub</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished subtraction&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_data</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_path</span> <span class="o">+</span> <span class="s1">&#39;data_zlpsub.npy&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data_zlpsub</span><span class="p">)</span></div>


    <span class="c1"># METHODS ON DATA MODIFICATION</span>
    <span class="c1">#TO DO remove pca_pixel, nmf_pixel, pca_cluster and nmf_cluster, these are not a correct application of the technique</span>
<div class="viewcode-block" id="SpectralImage.pool_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.pool_image">[docs]</a>
    <span class="k">def</span> <span class="nf">pool_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pools spectral image using a squared window of size ``area`` around each pixel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: numpy.ndarray (M,N)</span>
<span class="sd">            2D data set.</span>
<span class="sd">        area: int</span>
<span class="sd">            Pooling parameter: area around the pixel, must be an odd number</span>
<span class="sd">        kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">area</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to pool with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_p=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your pooling area is too large for one or both of the image axes, &quot;</span>
                             <span class="s2">&quot;please choose a number smaller than these values&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pooling of data started&quot;</span><span class="p">)</span>
        <span class="n">data_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">data_pool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_zlpsub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_pool_zlpsub</span> <span class="o">=</span> <span class="n">data_pool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_pool</span> <span class="o">=</span> <span class="n">data_pool</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pooling of data complete&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_pool</span></div>


<div class="viewcode-block" id="SpectralImage.pool_pixel">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.pool_pixel">[docs]</a>
    <span class="k">def</span> <span class="nf">pool_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">gaussian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pools the data of a squared window of size ``area`` around pixel (``i``, ``j``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        j: int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        area: int</span>
<span class="sd">            Pooling parameter: area around the pixel used for pooling, must be an odd number</span>
<span class="sd">        gaussian: boolean</span>
<span class="sd">            If true the pooling weights will use a gaussian distribution</span>
<span class="sd">        kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Pooled spectrum of the pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">area</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to pool with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_p=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your pooling area is too large for one or both of the image axes, &quot;</span>
                             <span class="s2">&quot;please choose a number smaller than these values&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gaussian</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Set up the pooling weights, basically a 1d gaussian to be used twice</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">area</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

        <span class="n">n_p_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n_p_border</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n_p_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_p_border</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n_p_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Check if the center pixel is on the border</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="n">x_min</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">weights_x</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">weights_x</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights_x</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">if</span> <span class="n">y_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="n">y_min</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">weights_y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">y_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_min</span><span class="p">)</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">weights_y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">y_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights_y</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">pooled_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights_x</span><span class="p">),</span>
                                      <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights_y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pooled_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights_x</span><span class="p">),</span>
                                      <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights_y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pooled_pixel</span></div>


<div class="viewcode-block" id="SpectralImage.pca_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.pca_image">[docs]</a>
    <span class="k">def</span> <span class="nf">pca_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">segments_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">segments_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">plot_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use principal component analysis on the spectral image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        area_type: str</span>
<span class="sd">            type of area used for principal component analysis. Usage types as follows:</span>
<span class="sd">                - ``&#39;segment&#39;``, the image is segmented and pca is only done per segmented areas.</span>
<span class="sd">                - ``&#39;cluster&#39;``, the data per cluster is used for pca within that cluster.</span>
<span class="sd">                - ``&#39;pixel&#39;``, only the data used around a pixel is used for pca of that pixel.</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value. Default is 0.9.</span>
<span class="sd">        segments_x: int</span>
<span class="sd">            For ``&#39;segment&#39;`` option, number of segments the x-axis is divided upon. Default is 1.</span>
<span class="sd">        segments_y: int</span>
<span class="sd">            For ``&#39;segment&#39;`` option, number of segments the y-axis is divided upon. Default is 1.</span>
<span class="sd">        kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA of segmented areas started&quot;</span><span class="p">)</span>
            <span class="n">segsize_x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">segments_x</span>
            <span class="n">segsize_y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">segments_y</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">segment_y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">segments_y</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">segment_x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">segments_x</span><span class="p">):</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_x</span> <span class="o">*</span> <span class="n">segment_x</span><span class="p">)</span>
                    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">segment_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_y</span> <span class="o">*</span> <span class="n">segment_y</span><span class="p">)</span>
                    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_y</span> <span class="o">*</span> <span class="p">(</span><span class="n">segment_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">seg_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">seg_data</span><span class="p">[</span><span class="n">seg_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
                        <span class="c1"># Normalize for poissonian noise</span>
                        <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                        <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                        <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                        <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

                    <span class="n">model</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
                    <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
                        <span class="c1"># rescale back the loadings and factors</span>
                        <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
                        <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">if</span> <span class="n">segments_x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">segments_y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># loadings_maps = loadings.reshape(seg_data_shape[:2] + (model.n_components_,))</span>
                        <span class="k">if</span> <span class="n">plot_variance</span><span class="p">:</span>
                            <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_pca_variance</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
                                                    <span class="n">eigenvalues_ratio</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;Scree_plot.pdf&#39;</span><span class="p">))</span>
                    <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">mean_</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="n">model_data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">X_model</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;cluster&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA of data per cluster started&quot;</span><span class="p">)</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">)):</span>
                <span class="n">model_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_cluster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster_idx</span><span class="p">,</span>
                                                                                  <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                                                                                  <span class="n">norm_poisson</span><span class="o">=</span><span class="n">norm_poisson</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA of data per pixel started&quot;</span><span class="p">)</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">model_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                                                      <span class="n">norm_poisson</span><span class="o">=</span><span class="n">norm_poisson</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;please pick a valid area type&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA of data complete&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model_data</span></div>


<div class="viewcode-block" id="SpectralImage.pca_pixel">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.pca_pixel">[docs]</a>
    <span class="k">def</span> <span class="nf">pca_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use principal component analysis on the spectral image, using the data of a squared window of size ``n_p``</span>
<span class="sd">        around pixel (``i``, ``j``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        j: int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        area: int</span>
<span class="sd">            PCA area parameter. Area around the pixel used for principal component analysis, must be an odd number</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value. Default is 0.9.</span>
<span class="sd">        deconv</span>
<span class="sd">        zlp_num</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: numpy.ndarray, shape=(M,)</span>
<span class="sd">            PCA spectrum of the pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">area</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to PCA with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_area=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your pixel area is too large for one or both of the image axes, &quot;</span>
                             <span class="s2">&quot;please choose a number smaller than these values&quot;</span><span class="p">)</span>

        <span class="c1"># Check pixel segment for borders</span>
        <span class="n">n_area_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_area_border</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n_area_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n_area_border</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n_area_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">x_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">y_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_min</span><span class="p">)</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">y_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">seg_data</span><span class="p">[</span><span class="n">seg_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># Normalize for poissonian noise</span>
            <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># rescale back the loadings and factors</span>
            <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
            <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">mean_</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">model_data</span> <span class="o">=</span> <span class="n">X_model</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">model_pixel</span> <span class="o">=</span> <span class="n">model_data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">model_pixel</span></div>


<div class="viewcode-block" id="SpectralImage.pca_cluster">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.pca_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">pca_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use principal component analysis on a cluster of the spectral image. The signals of the cluster are already</span>
<span class="sd">        in reduced format (pixel location is lost).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : numpy.ndarray, shape=(M,)</span>
<span class="sd">            An array with size equal to the number of clusters. Each entry is a 2D array that contains all the spectra</span>
<span class="sd">            within that cluster.</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value. Default is 0.9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cluster_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_signals</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">cluster_data</span><span class="p">[</span><span class="n">cluster_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># Normalize for poissonian noise</span>
            <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># rescale back the loadings and factors</span>
            <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
            <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">mean_</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">model_data</span> <span class="o">=</span> <span class="n">X_model</span>
        <span class="k">return</span> <span class="n">model_data</span></div>


<div class="viewcode-block" id="SpectralImage.nmf_image">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.nmf_image">[docs]</a>
    <span class="k">def</span> <span class="nf">nmf_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">segments_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">segments_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use non-negative matrix factorization on the spectral image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        area_type: str</span>
<span class="sd">            type of area used for principal component analysis. Usage types as follows:</span>
<span class="sd">                - ``&#39;segment&#39;``, the image is segmented and nmf is only done per segmented areas.</span>
<span class="sd">                - ``&#39;cluster&#39;``, the data per cluster is used for nmf within that cluster.</span>
<span class="sd">                - ``&#39;pixel&#39;``, only the data used around a pixel is used for nmf of that pixel.</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value by first running PCA. Default is 0.9.</span>
<span class="sd">        max_iter: int,</span>
<span class="sd">            Default is 100000</span>
<span class="sd">        segments_x: int</span>
<span class="sd">            For ``&#39;segment&#39;`` option, number of segments the x-axis is divided upon. Default is 1.</span>
<span class="sd">        segments_y: int</span>
<span class="sd">            For ``&#39;segment&#39;`` option, number of segments the y-axis is divided upon. Default is 1.</span>
<span class="sd">        kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NMF of segmented areas started&quot;</span><span class="p">)</span>
            <span class="n">segsize_x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">segments_x</span>
            <span class="n">segsize_y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">segments_y</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">segment_y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">segments_y</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">segment_x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">segments_x</span><span class="p">):</span>
                    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_x</span> <span class="o">*</span> <span class="n">segment_x</span><span class="p">)</span>
                    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_x</span> <span class="o">*</span> <span class="p">(</span><span class="n">segment_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_y</span> <span class="o">*</span> <span class="n">segment_y</span><span class="p">)</span>
                    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segsize_y</span> <span class="o">*</span> <span class="p">(</span><span class="n">segment_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">seg_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">seg_data</span><span class="p">[</span><span class="n">seg_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
                        <span class="c1"># Normalize for poissonian noise</span>
                        <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                        <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                        <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                        <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">model_pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">model_pca</span><span class="o">.</span><span class="n">n_components_</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
                    <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>
                    <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
                        <span class="c1"># rescale back the loadings and factors</span>
                        <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
                        <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
                    <span class="c1"># if segments_x == 1 and segments_y == 1:</span>
                    <span class="c1">#     loadings_maps = loadings.reshape(seg_data_shape[:2] + (model.n_components_,))</span>
                    <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">model_data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">X_model</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;cluster&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NMF of data per cluster started&quot;</span><span class="p">)</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">)):</span>
                <span class="n">model_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_cluster</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">cluster</span><span class="o">=</span><span class="n">cluster_idx</span><span class="p">,</span>
                                                                                  <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                                                                                  <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">area_type</span> <span class="o">==</span> <span class="s1">&#39;pixel&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NMF of data per pixel started&quot;</span><span class="p">)</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">model_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmf_pixel</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;please pick a valid area type&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NMF of data complete&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model_data</span></div>


<div class="viewcode-block" id="SpectralImage.nmf_cluster">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.nmf_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">nmf_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use non-negative matrix factorization on a cluster of the spectral image.</span>
<span class="sd">        The signals of the cluster are already in reduced format (pixel location is lost).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : numpy.ndarray, shape=(M,)</span>
<span class="sd">            An array with size equal to the number of clusters. Each entry is a</span>
<span class="sd">            2D array that contains all the spectra within that cluster.</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value by PCA first. Default is 0.9.</span>
<span class="sd">        max_iter: int,</span>
<span class="sd">            Default is 100000</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cluster_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_signals</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">cluster_data</span><span class="p">[</span><span class="n">cluster_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># Normalize for poissonian noise</span>
            <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model_pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model_pca</span><span class="o">.</span><span class="n">n_components_</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># rescale back the loadings and factors</span>
            <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
            <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span>
        <span class="n">model_data</span> <span class="o">=</span> <span class="n">X_model</span>
        <span class="k">return</span> <span class="n">model_data</span></div>


<div class="viewcode-block" id="SpectralImage.nmf_pixel">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.nmf_pixel">[docs]</a>
    <span class="k">def</span> <span class="nf">nmf_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">norm_poisson</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use principal component analysis on the spectral image, using the data of a squared window of size ``n_p``</span>
<span class="sd">        around pixel (``i``, ``j``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        j: int</span>
<span class="sd">            x-coordinate of the pixel</span>
<span class="sd">        area: int</span>
<span class="sd">            PCA area parameter. Area around the pixel used for principal component analysis, must be an odd number</span>
<span class="sd">        n_components: float,</span>
<span class="sd">            number components to calculate. If between 0 and 1 the amount of components will be determined based on the</span>
<span class="sd">            sum of the variance of the components below the given value by PCA first. Default is 0.9.</span>
<span class="sd">        max_iter: int,</span>
<span class="sd">            Default is 100000</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: numpy.ndarray, shape=(M,)</span>
<span class="sd">            PCA spectrum of the pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">area</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to NMF with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_area=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">area</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your pixel area is too large for one or both of the image axes, &quot;</span>
                             <span class="s2">&quot;please choose a number smaller than these values&quot;</span><span class="p">)</span>

        <span class="c1"># Check pixel area</span>
        <span class="n">n_area_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">n_area_border</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n_area_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n_area_border</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n_area_border</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">x_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">x_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">y_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y_max</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_min</span><span class="p">)</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">y_min</span> <span class="o">-=</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">seg_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">seg_data</span><span class="p">[</span><span class="n">seg_data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># Normalize for poissonian noise</span>
            <span class="n">aG</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">bH</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">root_aG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aG</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">root_bH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bH</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">X</span> <span class="o">/=</span> <span class="n">root_aG</span> <span class="o">*</span> <span class="n">root_bH</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model_pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model_pca</span><span class="o">.</span><span class="n">n_components_</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">norm_poisson</span><span class="p">:</span>
            <span class="c1"># rescale back the loadings and factors</span>
            <span class="n">loadings</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_aG</span>
            <span class="n">factors</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">root_bH</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X_model</span> <span class="o">=</span> <span class="n">factors</span> <span class="o">@</span> <span class="n">loadings</span><span class="o">.</span><span class="n">T</span>
        <span class="n">model_data</span> <span class="o">=</span> <span class="n">X_model</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seg_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">model_pixel</span> <span class="o">=</span> <span class="n">model_data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">model_pixel</span></div>


    <span class="c1"># METHODS ON SIGNAL</span>
<div class="viewcode-block" id="SpectralImage.smooth_signal">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.smooth_signal">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">smooth_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">window_type</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth a signal using a window length ``window_length`` and a window type ``window_type``.</span>

<span class="sd">        This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">        The signal is prepared by introducing reflected copies of the signal</span>
<span class="sd">        (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">        in the beginning and end part of the output signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Signal of length M</span>
<span class="sd">        window_length: int, optional</span>
<span class="sd">            The dimension of the smoothing window; should be an odd integer. Default is 51.</span>
<span class="sd">        window_type: str, optional</span>
<span class="sd">            the type of window from ``&#39;flat&#39;``, ``&#39;hanning&#39;``, ``&#39;hamming&#39;``, ``&#39;bartlett&#39;``,</span>
<span class="sd">            ``&#39;blackman&#39;`` and ``&#39;kaiser&#39;``. ``&#39;flat&#39;`` window will produce a moving average smoothing.</span>
<span class="sd">            Default is ``&#39;hanning&#39;``.</span>
<span class="sd">        beta: float, optional</span>
<span class="sd">            If using the kaiser window, beta determines the shape parameter for window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signal_smooth: numpy.ndarray, shape=(M,)</span>
<span class="sd">            The smoothed signal</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set window length to uneven number</span>
        <span class="n">window_length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>

        <span class="c1"># extend the signal with the window length on both ends</span>
        <span class="n">signal_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;-1&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="n">window_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signal</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s1">&#39;savgol&#39;</span><span class="p">:</span>
            <span class="n">signal_smooth</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pick the window type</span>
            <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>  <span class="c1"># moving average</span>
                <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_length</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s1">&#39;kaiser&#39;</span><span class="p">:</span>
                <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">window_type</span> <span class="o">+</span> <span class="s1">&#39;(window_length)&#39;</span><span class="p">)</span>
            <span class="c1"># Determine the smoothed signal and throw away the padded ends</span>
            <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">signal_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">signal_padded</span><span class="p">,</span> <span class="n">window</span> <span class="o">/</span> <span class="n">window</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)[</span>
                                <span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">signal_smooth</span></div>


<div class="viewcode-block" id="SpectralImage.deconvolution">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.deconvolution">[docs]</a>
    <span class="k">def</span> <span class="nf">deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">zlp</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform deconvolution on a given signal with a given Zero Loss Peak. This removes both the ZLP and plural</span>
<span class="sd">        scattering. Based on the Fourier Log Method :cite:p:`Johnson1974, Egerton2011`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Raw signal of length M</span>
<span class="sd">        zlp: numpy.ndarray, shape=(M,)</span>
<span class="sd">            zero-loss peak of length M</span>
<span class="sd">        correction: Bool</span>
<span class="sd">            Sometimes a decreasing linear slope occurs on the place of the ZLP after deconvolution. This correction fits</span>
<span class="sd">            a linear function and subtracts that from the signal. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: numpy.ndarray, shape=(M,)</span>
<span class="sd">            deconvoluted spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extrapolate data</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span>
        <span class="n">y_zlp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y_zlp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">zlp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span><span class="p">):</span>
            <span class="n">y_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_signal</span> <span class="o">=</span> <span class="n">signal</span>

        <span class="c1"># Fourier log method with Zero-loss modifier. See Egerton Chapter 4 for details</span>
        <span class="n">z_nu</span> <span class="o">=</span> <span class="n">cft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_zlp</span><span class="p">)</span>
        <span class="n">j_nu</span> <span class="o">=</span> <span class="n">cft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_signal</span><span class="p">)</span>
        <span class="n">j1_nu</span> <span class="o">=</span> <span class="n">z_nu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">j_nu</span> <span class="o">/</span> <span class="n">z_nu</span><span class="p">)</span>
        <span class="n">J1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">icft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">j1_nu</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">correction</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Correct for linear increase in ZLP and gain region.</span>
            <span class="n">zlp_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
            <span class="n">fwhm_idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">signal</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">zlp_peak</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">fwhm_idx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">signal</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">zlp_peak</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">fwhm_idx1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">fwhm_idx2</span><span class="p">])</span>

            <span class="n">dydx1_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">fwhm</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dydx2_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">fwhm</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">x_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">dydx1_idx</span><span class="p">:</span><span class="n">dydx2_idx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">y_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J1_E</span><span class="p">[</span><span class="n">dydx1_idx</span><span class="p">:</span><span class="n">dydx2_idx</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">linear_fit</span><span class="p">,</span> <span class="n">xdata</span><span class="o">=</span><span class="n">x_fit</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y_fit</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]))</span>

            <span class="n">deconv_corr</span> <span class="o">=</span> <span class="n">linear_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">deconv_corr</span><span class="p">[</span><span class="n">deconv_corr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Apply correction</span>
            <span class="n">J1_E</span> <span class="o">=</span> <span class="n">J1_E</span> <span class="o">-</span> <span class="n">deconv_corr</span>

        <span class="n">J1_E</span><span class="p">[</span><span class="n">J1_E</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J1_E</span><span class="p">[</span><span class="n">y_zlp</span> <span class="o">==</span> <span class="n">y_signal</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">J1_E</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralImage.rl_deconvolution">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.rl_deconvolution">[docs]</a>
    <span class="k">def</span> <span class="nf">rl_deconvolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">zlp</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Richardson-lucy deconvolution</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal</span>
<span class="sd">        zlp</span>
<span class="sd">        iterations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zlp_ch</span> <span class="o">=</span> <span class="n">zlp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">zlp</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="n">signal_rl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mimax_idx</span> <span class="o">=</span> <span class="n">zlp_ch</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">max_idx</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">zlp</span><span class="p">,</span> <span class="n">signal_rl</span><span class="p">)[</span><span class="n">max_idx</span><span class="p">:</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="n">zlp_ch</span><span class="p">]</span>
            <span class="n">signal_rl</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">zlp</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">first</span><span class="p">)[</span><span class="n">mimax_idx</span><span class="p">:</span> <span class="n">mimax_idx</span> <span class="o">+</span> <span class="n">zlp_ch</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">signal_rl</span></div>


<div class="viewcode-block" id="SpectralImage.subtract_zlp">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.subtract_zlp">[docs]</a>
    <span class="k">def</span> <span class="nf">subtract_zlp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">zlp</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract the Zero Loss Peak from the signal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Raw signal of length M</span>
<span class="sd">        zlp: numpy.ndarray, shape=(M,)</span>
<span class="sd">            zero-loss peak of length M</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">signal</span> <span class="o">-</span> <span class="n">zlp</span></div>


<div class="viewcode-block" id="SpectralImage.get_extrp_param">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_extrp_param">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extrp_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">range_perc</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the extrapolation parameter from the last 10% of a given signal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal: numpy.ndarray, shape=(M,)</span>
<span class="sd">        range_perc: float, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r: float.</span>
<span class="sd">            extrapolation parameter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_last</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">range_perc</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">x_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">idx_last</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">y_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">idx_last</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">power_fit</span><span class="p">,</span> <span class="n">x_fit</span><span class="p">,</span> <span class="n">y_fit</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="SpectralImage.extrp_signal">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.extrp_signal">[docs]</a>
    <span class="k">def</span> <span class="nf">extrp_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extrapolate your signal. Extrapolation model, generate vanishing to zero data after the real exp. data</span>
<span class="sd">        See Egerton paragraph 4.2.2 for details. extrapolation of the form A*E^-r is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal : numpy.ndarray, shape=(M,)</span>
<span class="sd">            spectrum</span>
<span class="sd">        r : float, optional</span>
<span class="sd">            extrapolation parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Starting amplitude for extrapolated data, endpoint of the exp. data</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extrp_param</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">power_fit</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span></div>


    <span class="c1"># METHODS ON ZLP</span>
<div class="viewcode-block" id="SpectralImage.get_pixel_matched_zlp_models">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_pixel_matched_zlp_models">[docs]</a>
    <span class="k">def</span> <span class="nf">get_pixel_matched_zlp_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape-(M, N) array of matched ZLP model predictions at pixel</span>
<span class="sd">        (``i``, ``j``) after training. M and N correspond to the number of model</span>
<span class="sd">        predictions and :math:`\Delta E` s respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i: int</span>
<span class="sd">            y-coordinate of the pixel.</span>
<span class="sd">        j: int</span>
<span class="sd">            x-coordinate of the pixel.</span>
<span class="sd">        signal_type: str, bool</span>
<span class="sd">            Description of signal type. Set to ``&#39;EELS&#39;`` by default.</span>
<span class="sd">        signal: array, bool,</span>
<span class="sd">            signal you want to match the zlps to. Important to do if you did not do any pooling, pca or nmf on the whole</span>
<span class="sd">            image, otherwise it will calculate the denoised signal twice.</span>
<span class="sd">        kwargs: dict, optional</span>
<span class="sd">            Additional keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictions: numpy.ndarray, shape=(M, N)</span>
<span class="sd">            The matched ZLP predictions at pixel (``i``, ``j``).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get pixel information</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">de1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="n">de2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE2</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FWHM</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>

        <span class="c1"># get zlp predictions</span>
        <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">int_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">max_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">max_idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zlp_models</span><span class="p">(</span><span class="n">int_i</span><span class="o">=</span><span class="n">int_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># match the predictions</span>
        <span class="n">predictions_matched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictions</span><span class="p">):</span>
            <span class="n">predictions_matched</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_zlp_to_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">de1</span><span class="p">,</span> <span class="n">de2</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">predictions_matched</span></div>


<div class="viewcode-block" id="SpectralImage.get_zlp_models">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.get_zlp_models">[docs]</a>
    <span class="k">def</span> <span class="nf">get_zlp_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">int_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape-(M, N) array of zlp model predictions at the</span>
<span class="sd">        integrated intensity ``int_i``. The logarithm of the integrated intensity is taken,</span>
<span class="sd">        as the data is always trained to log of the signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        int_i: float</span>
<span class="sd">            Integrated intensity</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_zlp_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_zlp_models</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_eaxis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_eaxis</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_int_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">log_int_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_int_i</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">log_int_i</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>

        <span class="c1"># Prepare the neural network input features (scaled eaxis and scaled log of the integrated intensity)</span>
        <span class="n">log_int_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">int_i</span><span class="p">)</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_eaxis</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_int_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_int_i</span><span class="p">)</span>
        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>

        <span class="c1"># Get the model predictions based on the neural network input features</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[:</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># Post-fit selection, if the prediction goes upward after the zlp peak, it is filtered out.</span>
        <span class="c1"># predictions_filtered = []</span>
        <span class="c1"># for j, prediction in enumerate(predictions):</span>
        <span class="c1">#     pred_lim = prediction[np.argwhere(self.eaxis &gt; self.eaxis[np.argmax(prediction) + 1]).flatten()]</span>
        <span class="c1">#     if not any(np.diff(pred_lim) &gt; 0.01):</span>
        <span class="c1">#         predictions_filtered.append(prediction)</span>
        <span class="c1"># predictions_filtered = np.array(predictions_filtered)</span>

        <span class="k">return</span> <span class="n">predictions</span> <span class="c1"># predictions_filtered</span></div>


<div class="viewcode-block" id="SpectralImage.match_zlp_to_signal">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.match_zlp_to_signal">[docs]</a>
    <span class="k">def</span> <span class="nf">match_zlp_to_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">zlp</span><span class="p">,</span> <span class="n">de1</span><span class="p">,</span> <span class="n">de2</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the matching to the subtracted spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Signal to be matched</span>
<span class="sd">        zlp: numpy.ndarray, shape=(M,)</span>
<span class="sd">            ZLP model to be matched, must match length of Signal.</span>
<span class="sd">        de1: float</span>
<span class="sd">            Value of the hyperparameter :math:`\Delta E_{I}`</span>
<span class="sd">        de2: float</span>
<span class="sd">            Value of the hyperparameter :math:`\Delta E_{II}`</span>
<span class="sd">        fwhm: float</span>
<span class="sd">            Value of the hyperparameter :math:`FWHM`. If none is given, a fwhm is determined from the signal.</span>
<span class="sd">            Default is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: numpy.ndarray, shape=(M,)</span>
<span class="sd">            Matched ZLP model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">fwhm_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">signal</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">peak</span><span class="p">)</span>
        <span class="n">fwhm_idx1</span> <span class="o">=</span> <span class="n">fwhm_window</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">fwhm_idx2</span> <span class="o">=</span> <span class="n">fwhm_window</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">fwhm_idx2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">fwhm_idx1</span><span class="p">]</span>

        <span class="n">de0</span> <span class="o">=</span> <span class="p">(</span><span class="n">fwhm</span> <span class="o">+</span> <span class="n">de1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">de0_m</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">de0</span>
        <span class="n">de1_m</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">de1</span>

        <span class="c1"># Right side ZLP (loss spectrum)</span>
        <span class="n">e_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="n">de1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;=</span> <span class="n">de0</span><span class="p">)]</span>
        <span class="c1"># delta = (de1 - de0) / 3.</span>
        <span class="c1"># factor_nn = np.exp(- (e_window - de1)**2 / delta**2)</span>
        <span class="c1"># factor_zlp = 1 - factor_model</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">de1</span> <span class="o">-</span> <span class="n">de0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.</span>
        <span class="n">factor_nn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">e_window</span> <span class="o">-</span> <span class="p">(</span><span class="n">de0</span> <span class="o">+</span> <span class="n">de1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span><span class="p">))</span>
        <span class="n">factor_zlp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_nn</span>

        <span class="c1"># Left side ZLP (gain spectrum)</span>
        <span class="n">e_window_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">de1_m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">de0_m</span><span class="p">)]</span>
        <span class="c1"># delta_m = (de1_m + de0_m) / 3.</span>
        <span class="c1"># factor_nn_m = np.exp(- (e_window_m - de1_m)**2 / delta_m**2)</span>
        <span class="c1"># factor_zlp_m = 1 - factor_model</span>
        <span class="n">delta_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">de1_m</span> <span class="o">+</span> <span class="n">de0_m</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.</span>
        <span class="n">factor_nn_m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">e_window_m</span> <span class="o">-</span> <span class="p">(</span><span class="n">de0_m</span> <span class="o">+</span> <span class="n">de1_m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_m</span><span class="p">))</span>
        <span class="n">factor_zlp_m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_nn_m</span>

        <span class="c1"># Match the ZLP to signal using the factors</span>
        <span class="n">range_m2</span> <span class="o">=</span> <span class="n">zlp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">de1_m</span><span class="p">]</span>
        <span class="n">range_m1</span> <span class="o">=</span> <span class="n">zlp</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">de1_m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">de0_m</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_nn_m</span> <span class="o">+</span> \
                   <span class="n">signal</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">de1_m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">de0_m</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_zlp_m</span>
        <span class="n">range_0</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">de0_m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="n">de0</span><span class="p">)]</span>     <span class="c1"># ZLP</span>
        <span class="n">range_1</span> <span class="o">=</span> <span class="n">zlp</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="n">de1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;=</span> <span class="n">de0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_nn</span> <span class="o">+</span> \
                  <span class="n">signal</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="n">de1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;=</span> <span class="n">de0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_zlp</span>
        <span class="n">range_2</span> <span class="o">=</span> <span class="n">zlp</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;=</span> <span class="n">de1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;=</span> <span class="n">de2</span><span class="p">)]</span>
        <span class="n">range_3</span> <span class="o">=</span> <span class="n">zlp</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="n">de2</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">0</span>   <span class="c1"># Rest of the spectrum</span>

        <span class="n">matched_zlp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">range_m2</span><span class="p">,</span> <span class="n">range_m1</span><span class="p">,</span> <span class="n">range_0</span><span class="p">,</span> <span class="n">range_1</span><span class="p">,</span> <span class="n">range_2</span><span class="p">,</span> <span class="n">range_3</span><span class="p">),</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matched_zlp</span></div>


<div class="viewcode-block" id="SpectralImage.train_zlp_models">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.train_zlp_models">[docs]</a>
    <span class="k">def</span> <span class="nf">train_zlp_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train the ZLP on the spectral image.</span>

<span class="sd">        The spectral image is clustered in ``n_clusters`` clusters, according to</span>
<span class="sd">        e.g. the integrated intensity or thickness. A random spectrum is then</span>
<span class="sd">        taken from each cluster, which together defines one replica. The</span>
<span class="sd">        training is initiated by calling</span>
<span class="sd">        :py:meth:`train_zlp_models_scaled() &lt;EELSFitter.core.training.train_zlp_models_scaled&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conf_interval: int, optional</span>
<span class="sd">            Default is 1</span>
<span class="sd">        lr: float, optional</span>
<span class="sd">            Default is 1</span>
<span class="sd">        signal_type: str, optional</span>
<span class="sd">            Type of spectrum. Set to EELS by default.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments that are passed to the method</span>
<span class="sd">            :py:meth:`train_zlp_models_scaled() &lt;EELSFitter.core.training.train_zlp_models_scaled&gt;`</span>
<span class="sd">            in the :py:mod:`training` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_signals</span><span class="p">(</span><span class="n">conf_interval</span><span class="o">=</span><span class="n">conf_interval</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_zlps</span> <span class="o">=</span> <span class="n">TrainZeroLossPeak</span><span class="p">(</span><span class="n">spectra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training_data</span><span class="p">,</span> <span class="n">eaxis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">,</span>
                                            <span class="n">cluster_centroids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_zlps</span><span class="o">.</span><span class="n">train_zlp_models_scaled</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span></div>



<div class="viewcode-block" id="SpectralImage.load_zlp_models">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.load_zlp_models">[docs]</a>
    <span class="k">def</span> <span class="nf">load_zlp_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span><span class="p">,</span> <span class="n">plot_chi2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_pred</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the trained ZLP models and stores them in ``self.zlp_models``.</span>
<span class="sd">        Models that have a :math:`\chi^2 &gt; \chi^2_{\mathrm{mean}} + 5\sigma` are</span>
<span class="sd">        discarded, where :math:`\sigma` denotes the 68% CI.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_to_models: str</span>
<span class="sd">            Location where the model predictions have been stored after training.</span>
<span class="sd">        plot_chi2: bool, optional</span>
<span class="sd">            When set to `True`, plot and save the :math:`\chi^2` distribution.</span>
<span class="sd">        plot_pred: bool, optional</span>
<span class="sd">            When set to `True`, plot and save the ZLP predictions per cluster.</span>
<span class="sd">        idx: int, optional</span>
<span class="sd">            When specified, only the zlp labelled by ``idx`` is loaded, instead</span>
<span class="sd">            of all model predictions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;No path &quot;</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot; found. Please ensure spelling </span><span class="se">\</span>
<span class="s2">                    and that there are models trained.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="s1">&#39;/&#39;</span>

        <span class="c1"># Load in the hyperparameters</span>
        <span class="n">path_hp</span> <span class="o">=</span> <span class="s1">&#39;hyperparameters.txt&#39;</span>
        <span class="n">hypar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="n">path_hp</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span> <span class="o">=</span> <span class="n">hypar</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE2</span> <span class="o">=</span> <span class="n">hypar</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FWHM</span> <span class="o">=</span> <span class="n">hypar</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading hyper-parameters complete&quot;</span><span class="p">)</span>

        <span class="c1"># Load in the scale variables for scaling on the log of the integrated intensity of the spectra.</span>
        <span class="n">path_scale_var</span> <span class="o">=</span> <span class="s1">&#39;scale_var.txt&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_int_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="n">path_scale_var</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading scale variables for zlp models complete&quot;</span><span class="p">)</span>

        <span class="c1"># Cluster image based on the models centroids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_centroids</span><span class="p">(</span><span class="n">hypar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Clustering based on cluster centroids complete&quot;</span><span class="p">)</span>

        <span class="c1"># Load in the models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MultilayerPerceptron</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;nn_replicas&#39;</span><span class="p">))[</span><span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">filename_test</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;costs_test.txt&#39;</span><span class="p">)</span>
        <span class="n">cost_tests</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename_test</span><span class="p">)</span>
        <span class="n">cost_tests_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">)</span>
        <span class="n">cost_tests_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cost_tests</span><span class="p">,</span> <span class="mi">68</span><span class="p">)</span>
        <span class="n">threshold_costs_tests</span> <span class="o">=</span> <span class="n">cost_tests_mean</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">cost_tests_std</span>
        <span class="n">cost_tests</span> <span class="o">=</span> <span class="n">cost_tests</span><span class="p">[</span><span class="n">cost_tests</span> <span class="o">&lt;</span> <span class="n">threshold_costs_tests</span><span class="p">]</span>

        <span class="n">filename_train</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;costs_train.txt&#39;</span><span class="p">)</span>
        <span class="n">cost_trains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename_train</span><span class="p">)</span>
        <span class="n">cost_trains_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">)</span>
        <span class="n">cost_trains_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">,</span> <span class="mi">68</span><span class="p">)</span>
        <span class="n">threshold_costs_trains</span> <span class="o">=</span> <span class="n">cost_trains_mean</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">cost_trains_std</span>

        <span class="n">nn_rep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cost_trains</span> <span class="o">&lt;</span> <span class="n">threshold_costs_trains</span><span class="p">)</span>
        <span class="n">cost_trains</span> <span class="o">=</span> <span class="n">cost_trains</span><span class="p">[</span><span class="n">cost_trains</span> <span class="o">&lt;</span> <span class="n">threshold_costs_trains</span><span class="p">]</span>

        <span class="n">nn_replicas_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="s1">&#39;nn_replicas&#39;</span><span class="p">)</span>
        <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">nn_replicas_path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">nn_rep_idx</span><span class="o">.</span><span class="n">flatten</span><span class="p">():</span>
            <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zlp_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading models complete&quot;</span><span class="p">)</span>

        <span class="c1"># plot the chi2 distributions</span>
        <span class="k">if</span> <span class="n">plot_chi2</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_cost_dist</span><span class="p">(</span><span class="n">cost_trains</span><span class="p">,</span> <span class="n">cost_tests</span><span class="p">,</span> <span class="n">cost_tests_std</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;chi2_dist.pdf&#39;</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chi2 plot saved at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">))</span>

        <span class="c1"># plot the zlp predictions for each cluster</span>
        <span class="k">if</span> <span class="n">plot_pred</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_zlp_cluster_predictions</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE2</span><span class="p">)],</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">yscale</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\rm{Energy\;loss\;[eV]}$&quot;</span><span class="p">,</span>
                                               <span class="n">title</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\rm{Cluster\;predictions\;}$&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;Cluster_predictions.pdf&#39;</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster predictions plot saved at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">))</span></div>


    <span class="c1"># METHODS ON QUANTITATIVE ANALYSIS</span>
<div class="viewcode-block" id="SpectralImage.set_refractive_index">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.set_refractive_index">[docs]</a>
    <span class="k">def</span> <span class="nf">set_refractive_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_background</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets value of refractive index for the image as attribute self.n. If not clustered, n will be an</span>
<span class="sd">        array of length one, otherwise it is an array of length n_clusters. If n_background is defined,</span>
<span class="sd">        the cluster with the lowest thickness (cluster 0) will be assumed to be the vacuum/background,</span>
<span class="sd">        and gets the value of the background refractive index.</span>

<span class="sd">        If there are more specimen present in the image, it is wise to check by hand what cluster belongs</span>
<span class="sd">        to what specimen, and set the values by running::</span>

<span class="sd">             image.n[cluster_i] = n_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : float</span>
<span class="sd">            refractive index of sample.</span>
<span class="sd">        n_background : float, optional</span>
<span class="sd">            if defined: the refractive index of the background/vacuum. This value will automatically be \</span>
<span class="sd">            assigned to pixels belonging to the thinnest cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
            <span class="k">if</span> <span class="n">n_background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># assume cluster 0 is background</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_background</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span></div>


<div class="viewcode-block" id="SpectralImage.set_mass_density">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.set_mass_density">[docs]</a>
    <span class="k">def</span> <span class="nf">set_mass_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho_background</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets value of mass density for the image as attribute self.rho. If not clustered, rho will be an</span>
<span class="sd">        array of length one, otherwise it is an array of length n_clusters. If rho_background is defined,</span>
<span class="sd">        the cluster with the lowest thickness (cluster 0) will be assumed to be the vacuum/background,</span>
<span class="sd">        and gets the value of the background mass density.</span>

<span class="sd">        If there are more specimen present in the image, it is wise to check by hand what cluster belongs</span>
<span class="sd">        to what specimen, and set the values by running::</span>

<span class="sd">             image.n[cluster_i] = n_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rho</span>
<span class="sd">        rho_background</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span>
            <span class="k">if</span> <span class="n">rho_background</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho_background</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span></div>


<div class="viewcode-block" id="SpectralImage.calc_thickness">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.calc_thickness">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_zlp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates thickness from sample data by one of two methods:</span>
<span class="sd">            - Kramer-Kronig sum rule using the refractive index :cite:p:`Egerton1987`</span>
<span class="sd">            - Log ratio using mass density :cite:p:`Iakoubovskii2008a`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal : numpy.ndarray, shape=(M,)</span>
<span class="sd">            spectrum</span>
<span class="sd">        n : float</span>
<span class="sd">            refraction index</span>
<span class="sd">        rho : float</span>
<span class="sd">            mass density</span>
<span class="sd">        n_zlp: float or int</span>
<span class="sd">            Set to 1 by default, for already normalized EELS spectra.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        t: float</span>
<span class="sd">            thickness</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If using the refractive index, surface scatterings are not corrected for.</span>
<span class="sd">        If you wish to correct for surface scatterings, please extract the thickness ``t`` from</span>
<span class="sd">        :py:meth:`kramers_kronig_analysis() &lt;EELSFitter.core.spectral_image.SpectralImage.kramers_kronig_analysis&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Microscope data</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span>  <span class="c1"># Electron gun voltage, KeV</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span>  <span class="c1"># Collection semi-angle, mrad</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convergence_angle</span>  <span class="c1"># Convergence semi-angle, mrad</span>

        <span class="c1"># Constants &amp; kinetic definitions (Egerton 2011 appendix E)</span>
        <span class="n">m_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_e</span> <span class="o">/</span> <span class="mf">1E3</span>  <span class="c1"># Electron mass, KeV</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="o">*</span> <span class="mf">1E9</span>  <span class="c1"># Bohr radius, nm</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">e0</span> <span class="o">/</span> <span class="n">m_e</span><span class="p">)</span>  <span class="c1"># Relativistic factor</span>
        <span class="n">T_eff</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Effective kinetic energy, KeV</span>

        <span class="c1"># Check if data is extrapolated</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">signal</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The mass density and the refractive index are &quot;</span>
                             <span class="s2">&quot;not defined. Please provide one of them.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide the refractive index OR the &quot;</span>
                             <span class="s2">&quot;mass density information, not both&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Prepare single scattering distribution, Only take values from E = 0 onward</span>
            <span class="n">x_spliced</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">y_spliced</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
            <span class="c1"># First perform Angular corrections (Egerton 2011 section 4.2.1)</span>
            <span class="n">theta_e</span> <span class="o">=</span> <span class="n">x_spliced</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>  <span class="c1"># Characteristic scattering angle (per energy loss), mrad</span>
            <span class="n">ang_cor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">/</span> <span class="n">theta_e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Angular/Aperture correction</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">y_spliced</span> <span class="o">/</span> <span class="n">ang_cor</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span>

            <span class="c1"># Thickness calculation</span>
            <span class="n">Im_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span> <span class="o">/</span> <span class="n">x_spliced</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span>
            <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">Im_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># proportionality constant (Egerton 2011 section 4.2.2)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">T_eff</span> <span class="o">*</span> <span class="mf">1E3</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_zlp</span>
        <span class="k">elif</span> <span class="n">rho</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Inelastic mean free path, based on Iakoubovskii et al. (2008) with gamma scaling suggestion from Egerton</span>
            <span class="n">theta_c</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Effective cutoff angle, mrad</span>
            <span class="k">if</span> <span class="n">theta_c</span> <span class="o">&gt;</span> <span class="n">beta</span><span class="p">:</span>
                <span class="n">theta_c</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">theta_e</span> <span class="o">=</span> <span class="mf">5.5</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">**</span> <span class="mf">0.3</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>  <span class="c1"># Characteristic scattering angle (from mass density), mrad</span>

            <span class="c1"># Calculate lamba, the mean free path</span>
            <span class="n">upper_term</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta_e</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">lower_term</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">theta_c</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">lmbda</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">/</span> <span class="n">theta_e</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">upper_term</span> <span class="o">/</span> <span class="n">lower_term</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta_c</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">theta_e</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Thickness calculation</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">lmbda</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_zlp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span></div>


<div class="viewcode-block" id="SpectralImage.kramers_kronig_analysis">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.kramers_kronig_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">kramers_kronig_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal_ssd</span><span class="p">,</span> <span class="n">n_zlp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the complex dielectric function from the single scattering distribution (SSD) ``signal_ssd`` following</span>
<span class="sd">        the Kramers-Krönig relations. This code is based on Egerton&#39;s MATlab code :cite:p:`Egerton2011`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal_ssd: numpy.ndarray, shape=(M,)</span>
<span class="sd">            SSD of length energy-loss (M)</span>
<span class="sd">        n_zlp: float</span>
<span class="sd">            Total integrated intensity of the ZLP</span>
<span class="sd">        iterations: int</span>
<span class="sd">            Number of the iterations for the internal loop to remove the</span>
<span class="sd">            surface plasmon contribution. If 1 the surface plasmon contribution</span>
<span class="sd">            is not estimated and subtracted (the default is 1).</span>
<span class="sd">        n: float</span>
<span class="sd">            The medium refractive index. Used for normalization of the</span>
<span class="sd">            SSD to obtain the energy loss function. If given the thickness</span>
<span class="sd">            is estimated and returned. It is only required when `t` is None.</span>
<span class="sd">        t: float</span>
<span class="sd">            The sample thickness in nm.</span>
<span class="sd">        delta: float</span>
<span class="sd">            Factor added to aid stability for calculating surface losses</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eps: numpy.ndarray</span>
<span class="sd">            The complex dielectric function,</span>

<span class="sd">                .. math::</span>
<span class="sd">                    \epsilon = \epsilon_1 + i*\epsilon_2,</span>

<span class="sd">        te: float</span>
<span class="sd">            local thickness</span>
<span class="sd">        srf_int: numpy.ndarray</span>
<span class="sd">            Surface losses correction</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Relativistic effects are not considered when correcting surface scattering.</span>
<span class="sd">        - The value of delta depends on the thickness of your sample and is qualitatively determined by how realistic</span>
<span class="sd">          the output is.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Microscope data</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">*</span> <span class="mf">1E3</span>  <span class="c1"># Electron gun voltage, converted to eV</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="o">/</span> <span class="mf">1E3</span>  <span class="c1"># Collection semi-angle, converted to rad</span>

        <span class="c1"># Check if data is extrapolated</span>
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis_extrp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal_ssd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_extrp</span><span class="p">):</span>
            <span class="n">y_extrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_ssd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_extrp</span> <span class="o">=</span> <span class="n">signal_ssd</span>

        <span class="c1"># Prepare spectrum</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x_extrp</span><span class="p">[</span><span class="n">x_extrp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">y_spliced</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y_extrp</span><span class="p">[</span><span class="n">x_extrp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y_spliced</span>
        <span class="n">y_srf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Constants &amp; kinetic definitions (Egerton 2011 appendix E)</span>
        <span class="n">m_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_e</span>  <span class="c1"># Electron mass, eV</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span>  <span class="c1"># Bohr radius, m</span>
        <span class="n">hbar_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_bar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>  <span class="c1"># Planck&#39;s constant * speed of light, eV*m</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">e0</span> <span class="o">/</span> <span class="n">m_e</span><span class="p">)</span>  <span class="c1"># Relativistic factor</span>
        <span class="n">T_eff</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Effective kinetic energy, eV</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T_eff</span> <span class="o">*</span> <span class="n">m_e</span><span class="p">)</span> <span class="o">/</span> <span class="n">hbar_c</span>  <span class="c1"># Wavenumber, m^-1</span>

        <span class="c1"># select refractive or thickness loop</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The refractive index and thickness are not defined. Please provide ONLY one of them.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide the refractive index OR the thickness, not both&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">refractive_loop</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">refractive_loop</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="mf">1E9</span>  <span class="c1"># Thickness, converted to m</span>
            <span class="k">if</span> <span class="n">n_zlp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide the ZLP  when thickness is used for normalization.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># Calculation of the ELF by normalization of the Single Scattering Distribution</span>
            <span class="c1"># First perform Angular corrections (Egerton 2011 section 4.2.1)</span>
            <span class="n">theta_e</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>  <span class="c1"># Characteristic scattering angle (per energy loss), rad</span>
            <span class="n">ang_cor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">/</span> <span class="n">theta_e</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Angular/Aperture correction</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">ang_cor</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span>  <span class="c1"># Im[-1/eps]</span>

            <span class="k">if</span> <span class="n">refractive_loop</span><span class="p">:</span>
                <span class="c1"># normalize using the refractive index.</span>
                <span class="n">Im_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">Im_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># proportionality constant (Egerton 2011 section 4.2.2)</span>
                <span class="k">if</span> <span class="n">n_zlp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_zlp</span>   <span class="c1"># Calculate thickness</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normalize using the thickness</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">n_zlp</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>    <span class="c1"># proportionality constant from thickness</span>
                <span class="n">te</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="n">K</span>

            <span class="c1"># Kramers Kronig Transform:</span>
            <span class="c1">#  We calculate KKT(Im(-1/epsilon))=1+Re(1/epsilon) with FFT</span>
            <span class="c1">#  Follows: D W Johnson 1975 J. Phys. A: Math. Gen. 8 490</span>
            <span class="c1">#  Use an optimal FFT size to speed up the calculation, and make it double the closest upper value to</span>
            <span class="c1">#  work around the wrap-around problem.</span>
            <span class="n">optimal_fft_bins</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">bins</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span><span class="n">Im</span><span class="p">,</span> <span class="n">optimal_fft_bins</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">optimal_fft_bins</span>
            <span class="n">q</span><span class="p">[:</span><span class="n">bins</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">Re</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:</span><span class="n">bins</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Final touch, we have Re[1/eps]</span>

            <span class="c1"># Epsilon appears:</span>
            <span class="c1">#  We calculate the real and imaginary parts of the CDF</span>
            <span class="n">eps_1</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">eps_2</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_zlp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># See Egerton 2011 section 4.2.4, Ritchie (1957) and Heather (1967)</span>
                <span class="c1"># Calculates the surface ELF from a vacuum border effect and subtracts from the ELF.</span>
                <span class="c1"># delta = 0.1 for thick samples (&gt;100nm).</span>
                <span class="n">theta_delta_e</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>

                <span class="n">Im_srf</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">eps_2</span> <span class="o">/</span> <span class="p">((</span><span class="n">eps_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eps_2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Im</span>
                <span class="n">dPsdE</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">beta</span> <span class="o">/</span> <span class="n">theta_e</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">theta_e</span> <span class="o">+</span> <span class="n">theta_delta_e</span><span class="p">)</span>
                         <span class="o">-</span> <span class="n">beta</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">theta_e</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">*</span> <span class="n">T_eff</span><span class="p">)</span>
                <span class="n">y_srf</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_zlp</span> <span class="o">*</span> <span class="n">dPsdE</span> <span class="o">*</span> <span class="n">Im_srf</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span>

                <span class="n">y</span> <span class="o">=</span> <span class="n">y_spliced</span> <span class="o">-</span> <span class="n">y_srf</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="p">(</span><span class="n">eps_1</span> <span class="o">+</span> <span class="n">eps_2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eps</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">te</span><span class="o">*</span><span class="mf">1E9</span><span class="p">,</span> <span class="n">y_srf</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>


<div class="viewcode-block" id="SpectralImage.KK_pixel">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.KK_pixel">[docs]</a>
    <span class="k">def</span> <span class="nf">KK_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mat_prop</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a Kramer-Krönig analysis on pixel (``i``, ``j``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            y-coordinate of the pixel</span>
<span class="sd">        j : int</span>
<span class="sd">            x-coordinate of the pixel.</span>
<span class="sd">        signal_type: str, optional</span>
<span class="sd">            Type of spectrum. Set to &#39;EELS&#39; by default.</span>
<span class="sd">        iterations: int</span>
<span class="sd">            Number of the iterations for the internal loop to remove the</span>
<span class="sd">            surface plasmon contribution. If 1 the surface plasmon contribution</span>
<span class="sd">            is not estimated and subtracted (the default is 1).</span>
<span class="sd">        mat_prop: str, optional</span>
<span class="sd">            Material property to be used for calculations, &#39;n&#39; refers to refractive index, &#39;rho&#39; refers to mass density.</span>
<span class="sd">            Set to &#39;n&#39; by default</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dielectric_functions : numpy.ndarray, shape=(M,)</span>
<span class="sd">            Collection dielectric-functions replicas at pixel (``i``, ``j``).</span>
<span class="sd">        ts : float</span>
<span class="sd">            Thickness.</span>
<span class="sd">        S_ss : array_like</span>
<span class="sd">            Surface scatterings.</span>
<span class="sd">        signal_ssds : array_like</span>
<span class="sd">            Deconvoluted EELS spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mat_prop</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">mat_prop</span> <span class="o">==</span> <span class="s1">&#39;rho&#39;</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please select either the refractive index by setting mat_prop = &#39;n&#39; OR &quot;</span>
                             <span class="s2">&quot;the mass density by setting mat_prop = &#39;rho&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Get your signal ready</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">zlps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_matched_zlp_models</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal_type</span><span class="o">=</span><span class="n">signal_type</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">signal_extrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">)</span>

        <span class="c1"># Prepare arrays</span>
        <span class="n">epss</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlps</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlps</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">signal_ssds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlps</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">max_signal_ssds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zlps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Loop through all models</span>
        <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zlps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">zlp_k</span> <span class="o">=</span> <span class="n">zlps</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">n_zlp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zlp_k</span><span class="p">))</span>
            <span class="n">signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolution</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_extrp</span><span class="p">,</span> <span class="n">zlp</span><span class="o">=</span><span class="n">zlp_k</span><span class="p">)</span>
            <span class="n">max_signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extrp_param</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">signal_ssd_extrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal_ssd_extrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrp_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_ssds</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mat_prop</span> <span class="o">==</span> <span class="s1">&#39;rho&#39;</span><span class="p">:</span>
                <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_thickness</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal_extrp</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">n_zlp</span><span class="o">=</span><span class="n">n_zlp</span><span class="p">)</span>
                <span class="n">epss</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_analysis</span><span class="p">(</span><span class="n">signal_ssd</span><span class="o">=</span><span class="n">signal_ssd_extrp</span><span class="p">,</span> <span class="n">n_zlp</span><span class="o">=</span><span class="n">n_zlp</span><span class="p">,</span>
                                                                          <span class="n">t</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mat_prop</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">epss</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_analysis</span><span class="p">(</span><span class="n">signal_ssd</span><span class="o">=</span><span class="n">signal_ssd_extrp</span><span class="p">,</span> <span class="n">n_zlp</span><span class="o">=</span><span class="n">n_zlp</span><span class="p">,</span>
                                                                          <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epss</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">signal_ssds</span><span class="p">,</span> <span class="n">max_signal_ssds</span></div>


    <span class="c1"># METHODS ON CLUSTERING</span>
<div class="viewcode-block" id="SpectralImage.cluster">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="s1">&#39;log_zlp&#39;</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span> <span class="n">n_times</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">save_seed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lloyd&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clusters the spectral image into clusters according to the (log)</span>
<span class="sd">        integrated intensity at each pixel. Cluster means are stored in the</span>
<span class="sd">        attribute ``self.cluster_centroids``. This is then passed on to the</span>
<span class="sd">        cluster_on_centroids function where the index to which each cluster belongs</span>
<span class="sd">        is stored in the attribute ``self.cluster_labels``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters : int, optional</span>
<span class="sd">            Number of clusters, 5 by default</span>
<span class="sd">        based_on : str, optional</span>
<span class="sd">            One can cluster either on the sum of the intensities (pass ``&#39;sum&#39;``),</span>
<span class="sd">            the log of the sum (pass ``&#39;log_sum&#39;``),</span>
<span class="sd">            the log of the ZLP peak value (pass ``&#39;log_peak&#39;``),</span>
<span class="sd">            the log of the ZLP peak value + the two bins next to the peak value (pass ``&#39;log_zlp&#39;``),</span>
<span class="sd">            the log of the sum of the bulk spectrum (no zlp) (pass ``&#39;log_bulk&#39;``),</span>
<span class="sd">            the thickness (pass ``&#39;thickness&#39;``).</span>
<span class="sd">            The default is ``&#39;log_zlp&#39;``.</span>
<span class="sd">        init : {&#39;k-means++&#39;, &#39;random&#39;}, callable or array-like of shape \</span>
<span class="sd">            (n_clusters, n_features), default=&#39;k-means++&#39;</span>
<span class="sd">        n_times : int, default=10</span>
<span class="sd">            Number of time the k-means algorithm will be run with different</span>
<span class="sd">            centroid seeds. The final results will be the best output of</span>
<span class="sd">            n_init consecutive runs in terms of inertia.</span>
<span class="sd">        max_iter : int, default=300</span>
<span class="sd">            Maximum number of iterations of the k-means algorithm for a</span>
<span class="sd">            single run.</span>
<span class="sd">        seed : int or None, default=None</span>
<span class="sd">            Determines random number generation for centroid initialization. Use</span>
<span class="sd">            an int to make the randomness deterministic.</span>
<span class="sd">        save_seed : bool, default=False</span>
<span class="sd">            save the seed with corresponding settings to get to the same result</span>
<span class="sd">        algorithm : {&#39;lloyd&#39;, &#39;elkan&#39;}, default=&#39;lloyd&#39;</span>
<span class="sd">            K-means algorithm to use. The classical EM-style algorithm is ``&#39;lloyd&#39;``.</span>
<span class="sd">            The ``&#39;elkan&#39;`` variation can be more efficient on some datasets with</span>
<span class="sd">            well-defined clusters, by using the triangle inequality. However, it&#39;s</span>
<span class="sd">            more memory intensive due to the allocation of an extra array of shape</span>
<span class="sd">            `(n_samples, n_clusters)`.</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spectra</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not much to cluster on with a single spectrum&quot;</span><span class="p">)</span>
            <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="mi">12345678</span>
            <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">image_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">image_data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_sum&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_peak&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_zlp&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">intensities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_bulk&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;thickness&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">based_on</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">based_on</span>
            <span class="k">if</span> <span class="n">intensities</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spectra</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The size of values on which to cluster does not match the image size.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provide either sum, log or thickness as clustering base, reverting back to sum&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed_init</span> <span class="o">=</span> <span class="n">seed</span>
            <span class="n">n_times</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">cost_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">intensities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_times</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seed_init</span> <span class="o">=</span> <span class="n">get_seed</span><span class="p">()</span>
            <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                            <span class="n">random_state</span><span class="o">=</span><span class="n">seed_init</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">algorithm</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cost_min</span> <span class="o">&gt;</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span><span class="p">:</span>
                <span class="n">cost_min</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span>
                <span class="n">min_cluster_centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">min_seed</span> <span class="o">=</span> <span class="n">seed_init</span>
                <span class="n">min_iter</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">n_iter_</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Seed: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seed_init</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; finished after &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">kmeans</span><span class="o">.</span><span class="n">n_iter_</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iterations and has cost: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Seed: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">min_seed</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; has the lowest cost&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">min_cluster_centroids</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster centroids are&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_centroids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="n">based_on</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_seed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving seed.txt parameters, sit tight!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;seed = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; clusters = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span> <span class="o">+</span>
                  <span class="s2">&quot; iterations = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_means_cluster</span><span class="o">.</span><span class="n">n_iter</span><span class="p">))</span>
            <span class="n">path_seed</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;seed.txt&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">path_seed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">min_iter</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved seed.txt!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.cluster_on_centroids">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.cluster_on_centroids">[docs]</a>
    <span class="k">def</span> <span class="nf">cluster_on_centroids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_centroids</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="s1">&#39;log_zlp&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the image has been clustered before and the cluster centroids are</span>
<span class="sd">        already known, one can use this function to reconstruct the original</span>
<span class="sd">        clustering of the image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_centroids : numpy.ndarray, shape=(M,)</span>
<span class="sd">            Array with the cluster centroids</span>
<span class="sd">        based_on : str, optional</span>
<span class="sd">            One can cluster either on the sum of the intensities (pass ``&#39;sum&#39;``),</span>
<span class="sd">            the log of the sum (pass ``&#39;log_sum&#39;``),</span>
<span class="sd">            the log of the ZLP peak value (pass ``&#39;log_peak&#39;``),</span>
<span class="sd">            the log of the ZLP peak value + the two bins next to the peak value (pass ``&#39;log_zlp&#39;``),</span>
<span class="sd">            the log of the sum of the bulk spectrum (no zlp) (pass ``&#39;log_bulk&#39;``),</span>
<span class="sd">            the thickness (pass ``&#39;thickness&#39;``).</span>
<span class="sd">            The default is ``&#39;log_zlp&#39;``.</span>
<span class="sd">        kwargs</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_centroids</span> <span class="o">=</span> <span class="n">cluster_centroids</span>
        <span class="n">image_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">image_data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_sum&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_peak&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_zlp&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_bulk&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;thickness&#39;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">based_on</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">based_on</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spectra</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The size of values on which to cluster does not match the image size.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provide either sum, log or thickness as value base, reverting back to sum&quot;</span><span class="p">)</span>

        <span class="n">valar</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">valar</span> <span class="o">-</span> <span class="n">cluster_centroids</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# of spectra per cluster is&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;it seems like the clustered values of dE1 are not clustered on </span><span class="se">\</span>
<span class="s2">                    this image/on log or sum. Please check clustering.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralImage.find_optimal_amount_of_clusters">
<a class="viewcode-back" href="../../../modules/EELSFitter.core.html#EELSFitter.core.spectral_image.SpectralImage.find_optimal_amount_of_clusters">[docs]</a>
    <span class="k">def</span> <span class="nf">find_optimal_amount_of_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="s1">&#39;log_zlp&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the optimal amount of clusters by performing a Gaussian Mixture model on the specific data intensities.</span>
<span class="sd">        The user will need to judge what is best</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters</span>
<span class="sd">        bins</span>
<span class="sd">        based_on</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">image_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">image_data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_sum&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_peak&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_zlp&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">intensities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">max_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;log_bulk&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">image_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="mf">1e-14</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">based_on</span> <span class="o">==</span> <span class="s1">&#39;thickness&#39;</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">based_on</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">based_on</span>
            <span class="k">if</span> <span class="n">intensities</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_spectra</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The size of values on which to cluster does not match the image size.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provide either sum, log or thickness as clustering base, reverting back to sum&quot;</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">intensities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gm</span> <span class="o">=</span> <span class="n">GaussianMixture</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Evaluate GMM</span>
        <span class="n">gm_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">intensities</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">intensities</span><span class="p">),</span> <span class="mi">256</span><span class="p">)</span>
        <span class="n">gm_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">score_samples</span><span class="p">(</span><span class="n">gm_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;tab:blue&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gm_x</span><span class="p">,</span> <span class="n">gm_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;tab:red&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;GMM&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Pixel Intensity&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>


    <span class="k">def</span> <span class="nf">get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;data&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;ieels&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;zlp&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;eps&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">THICKNESS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;thickness&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines behavior of `self[key]`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Spectral image: &quot;</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;, image size:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;x&quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;, eaxis range: [&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> \
            <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> \
            <span class="s2">&quot;], deltaE: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data_str</span> <span class="o">=</span> <span class="s2">&quot;data * np.ones(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Spectral_image(&quot;</span> <span class="o">+</span> <span class="n">data_str</span> <span class="o">+</span> <span class="s2">&quot;, deltaE=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>



<span class="c1"># STATIC FUNCTIONS</span>
<span class="k">def</span> <span class="nf">cft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fourier Transformation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: numpy.ndarray, shape=(M,)</span>
<span class="sd">    y: numpy.ndarray, shape=(M,)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F_k: numpy.ndarray, shape=(M,)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">cont_factor</span> <span class="o">*</span> <span class="n">delta_x</span>
    <span class="k">return</span> <span class="n">F_k</span>


<span class="k">def</span> <span class="nf">icft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Y_k</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse Fourier Transformation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: numpy.ndarray, shape=(M,)</span>
<span class="sd">    Y_k: numpy.ndarray, shape=(M,)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f_n: numpy.ndarray, shape=(M,)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">N_0</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">Y_k</span> <span class="o">*</span> <span class="n">cont_factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_x</span>
    <span class="k">return</span> <span class="n">f_n</span>


<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale the input features by applying a linear map such that the range</span>
<span class="sd">    covers 0.1 to 0.9.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    inp: numpy.ndarray, shape=(M,)</span>
<span class="sd">        Input feature array of length M</span>
<span class="sd">    ab: list</span>
<span class="sd">        Contains rescaling parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: numpy.ndarray, shape=(M,)</span>
<span class="sd">        Rescaled features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">inp</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">find_scale_var</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">min_out</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_out</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find rescaling parameters such that the input features lie between 0.1 and 0.9</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inp: numpy.ndarray, shape=(M,)</span>
<span class="sd">        Input feature array of length M</span>
<span class="sd">    min_out: float, optional</span>
<span class="sd">        Minimum of input feature, set to 0.1 by default</span>
<span class="sd">    max_out: float, optional</span>
<span class="sd">        Maximum of input feature, set to 0.9 by default</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: list</span>
<span class="sd">        Rescaling parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_out</span> <span class="o">-</span> <span class="n">min_out</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">min_out</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">round_scientific</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round ``value`` off to ``n_sig`` digits.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value: float</span>
<span class="sd">    n_sig: int</span>
<span class="sd">        Number of signicant digits</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: float</span>
<span class="sd">        Rounded version of ``value``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span> <span class="o">-</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num</span>


<span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">decs</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the truncated version of the input</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values: numpy.ndarray, shape=(M,)</span>
<span class="sd">        Input array</span>
<span class="sd">    decs: int</span>
<span class="sd">        Number of decimals to keep</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: truncated version of the input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">values</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">decs</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">decs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_seed</span><span class="p">(</span><span class="n">n_min</span><span class="o">=</span><span class="mf">1e7</span><span class="p">,</span> <span class="n">n_max</span><span class="o">=</span><span class="mf">1e8</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n_min</span><span class="p">,</span> <span class="n">n_max</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">linear_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">power_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">gauss1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">    mx</span>
<span class="sd">    sx</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">gauss2d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">my</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns values for a 2d gaussian distribution</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">    y</span>
<span class="sd">    mx</span>
<span class="sd">    my</span>
<span class="sd">    sx</span>
<span class="sd">    sy</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">sy</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="o">-</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mx</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">sx</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">my</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">sy</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EELSFitter developer team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>